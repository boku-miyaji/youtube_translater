import React, { useState, useRef, useEffect } from 'react'
import MarkdownRenderer from './MarkdownRenderer'

interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
  timestamp: Date
}

interface ChatInterfaceProps {
  videoId?: string
  prefillQuestion?: string
  videoTitle?: string
  transcript?: string
  summary?: string
  gptModel?: string
}

const ChatInterface: React.FC<ChatInterfaceProps> = ({ videoId, prefillQuestion, videoTitle, transcript, summary, gptModel }) => {
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [input, setInput] = useState('')
  const [loading, setLoading] = useState(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  
  // Ensure transcript and summary are strings for all usage and handle empty strings
  const safeTranscript = typeof transcript === 'string' ? transcript : (transcript ? String(transcript) : '')
  const safeSummary = typeof summary === 'string' ? summary : (summary ? String(summary) : '')
  
  // Additional validation for meaningful content (not just empty strings)
  const hasValidTranscript = safeTranscript && safeTranscript.trim().length > 0
  const hasValidSummary = safeSummary && safeSummary.trim().length > 0
  
  // Simplified content check for UI purposes
  const hasAnyContentForUI = (safeTranscript && safeTranscript.length > 0) || (safeSummary && safeSummary.length > 0)
  
  console.log('üîç ChatInterface data validation:')
  console.log('  - raw transcript prop:', transcript ? {
    type: typeof transcript,
    length: typeof transcript === 'string' ? transcript.length : 'NOT_STRING',
    preview: typeof transcript === 'string' ? transcript.substring(0, 100) + '...' : JSON.stringify(transcript).substring(0, 100) + '...',
    isEmptyString: transcript === '',
    isTruthy: !!transcript
  } : 'MISSING')
  console.log('  - raw summary prop:', summary ? {
    type: typeof summary,
    length: typeof summary === 'string' ? summary.length : 'NOT_STRING',
    preview: typeof summary === 'string' ? summary.substring(0, 100) + '...' : JSON.stringify(summary).substring(0, 100) + '...',
    isEmptyString: summary === '',
    isTruthy: !!summary
  } : 'MISSING')
  console.log('  - safeTranscript:', safeTranscript ? {
    type: typeof safeTranscript,
    length: safeTranscript.length,
    preview: safeTranscript.substring(0, 100) + '...',
    trimLength: safeTranscript.trim().length
  } : 'MISSING')
  console.log('  - safeSummary:', safeSummary ? {
    type: typeof safeSummary,
    length: safeSummary.length,
    preview: safeSummary.substring(0, 100) + '...',
    trimLength: safeSummary.trim().length
  } : 'MISSING')
  console.log('  - hasValidTranscript:', hasValidTranscript, '(safeTranscript &&', !!safeTranscript, 'safeTranscript.trim().length > 0:', safeTranscript ? safeTranscript.trim().length > 0 : 'N/A', ')')
  console.log('  - hasValidSummary:', hasValidSummary, '(safeSummary &&', !!safeSummary, 'safeSummary.trim().length > 0:', safeSummary ? safeSummary.trim().length > 0 : 'N/A', ')')

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' })
  }

  useEffect(() => {
    scrollToBottom()
  }, [messages])

  // Handle prefilled questions
  useEffect(() => {
    if (prefillQuestion && prefillQuestion.trim()) {
      setInput(prefillQuestion.trim())
    }
  }, [prefillQuestion])

  const sendMessage = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!input.trim() || loading) return
    
    // Check if we have any transcript content before making API call
    // Allow if either transcript or summary has any content (even if not perfectly valid)
    const hasAnyContent = (safeTranscript && safeTranscript.length > 0) || (safeSummary && safeSummary.length > 0)
    
    console.log('üéØ === PRE-REQUEST CONTENT CHECK ===')
    console.log('  - hasValidTranscript:', hasValidTranscript)
    console.log('  - hasValidSummary:', hasValidSummary)
    console.log('  - hasAnyContent:', hasAnyContent)
    console.log('  - safeTranscript exists and has content:', !!(safeTranscript && safeTranscript.length > 0))
    console.log('  - safeSummary exists and has content:', !!(safeSummary && safeSummary.length > 0))
    
    if (!hasAnyContent) {
      console.log('‚ùå No content available - showing error')
      const errorMessage: ChatMessage = {
        role: 'assistant',
        content: '„Åæ„ÅöÂãïÁîª„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶ÊñáÂ≠óËµ∑„Åì„Åó„ÇíÁîüÊàê„Åó„Å¶„Åã„ÇâË≥™Âïè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ',
        timestamp: new Date(),
      }
      setMessages(prev => [...prev, {
        role: 'user',
        content: input.trim(),
        timestamp: new Date(),
      }, errorMessage])
      setInput('')
      return
    }
    
    console.log('‚úÖ Content available - proceeding with request')

    const userMessage: ChatMessage = {
      role: 'user',
      content: input.trim(),
      timestamp: new Date(),
    }

    setMessages(prev => [...prev, userMessage])
    setInput('')
    setLoading(true)

    try {
      // Force sending transcript and summary if they are non-empty strings
      // This ensures server gets the data for historical videos
      const transcriptToSend = (safeTranscript && safeTranscript.length > 0) ? safeTranscript : undefined
      const summaryToSend = (safeSummary && safeSummary.length > 0) ? safeSummary : undefined
      
      const requestData = {
        message: input.trim(),
        videoId,
        history: messages,
        transcript: transcriptToSend,
        summary: summaryToSend,
        gptModel: gptModel || 'gpt-4o-mini',
      }
      
      console.log('üéØ === FORCE SEND LOGIC ===')
      console.log('  - safeTranscript value:', safeTranscript ? `"${safeTranscript.substring(0, 50)}..."` : 'MISSING/EMPTY')
      console.log('  - safeTranscript length:', safeTranscript ? safeTranscript.length : 0)
      console.log('  - safeSummary value:', safeSummary ? `"${safeSummary.substring(0, 50)}..."` : 'MISSING/EMPTY')
      console.log('  - safeSummary length:', safeSummary ? safeSummary.length : 0)
      console.log('  - transcriptToSend:', transcriptToSend ? `"${transcriptToSend.substring(0, 50)}..."` : 'UNDEFINED')
      console.log('  - summaryToSend:', summaryToSend ? `"${summaryToSend.substring(0, 50)}..."` : 'UNDEFINED')
      console.log('  - Will send transcript:', !!requestData.transcript, '(length:', requestData.transcript ? requestData.transcript.length : 0, ')')
      console.log('  - Will send summary:', !!requestData.summary, '(length:', requestData.summary ? requestData.summary.length : 0, ')')
      
      console.log('\nüöÄ === CLIENT CHAT REQUEST DEBUG ===')
      console.log('üì§ Original props received by ChatInterface:')
      console.log('  - transcript prop:', transcript ? {
        type: typeof transcript,
        length: typeof transcript === 'string' ? transcript.length : 'NOT_STRING',
        preview: typeof transcript === 'string' ? transcript.substring(0, 100) + '...' : JSON.stringify(transcript).substring(0, 100) + '...'
      } : 'MISSING')
      console.log('  - summary prop:', summary ? {
        type: typeof summary,
        length: typeof summary === 'string' ? summary.length : 'NOT_STRING',
        preview: typeof summary === 'string' ? summary.substring(0, 100) + '...' : JSON.stringify(summary).substring(0, 100) + '...'
      } : 'MISSING')
      
      console.log('üì§ Safe converted values:')
      console.log('  - safeTranscript:', safeTranscript ? {
        type: typeof safeTranscript,
        length: safeTranscript.length,
        preview: safeTranscript.substring(0, 100) + '...'
      } : 'MISSING')
      console.log('  - safeSummary:', safeSummary ? {
        type: typeof safeSummary,
        length: safeSummary.length,
        preview: safeSummary.substring(0, 100) + '...'
      } : 'MISSING')
      
      console.log('üì§ Validation status:')
      console.log('  - hasValidTranscript:', hasValidTranscript)
      console.log('  - hasValidSummary:', hasValidSummary)
      console.log('  - Condition check - hasValidTranscript ? safeTranscript : "":', hasValidTranscript ? 'USING_TRANSCRIPT' : 'USING_EMPTY_STRING')
      console.log('  - Condition check - hasValidSummary ? safeSummary : "":', hasValidSummary ? 'USING_SUMMARY' : 'USING_EMPTY_STRING')
      
      console.log('üì§ Final request data to be sent:')
      console.log('  - message:', requestData.message)
      console.log('  - videoId:', requestData.videoId)
      console.log('  - historyLength:', requestData.history.length)
      console.log('  - gptModel:', requestData.gptModel)
      console.log('  - gptModel from props:', gptModel)
      console.log('  - transcript in request:', requestData.transcript ? {
        type: typeof requestData.transcript,
        length: requestData.transcript.length,
        preview: requestData.transcript.substring(0, 100) + '...',
        isEmptyString: requestData.transcript === '',
        trimmedLength: requestData.transcript.trim().length
      } : 'MISSING_OR_FALSY')
      console.log('  - summary in request:', requestData.summary ? {
        type: typeof requestData.summary,
        length: requestData.summary.length,
        preview: requestData.summary.substring(0, 100) + '...',
        isEmptyString: requestData.summary === '',
        trimmedLength: requestData.summary.trim().length
      } : 'MISSING_OR_FALSY')
      
      console.log('üì§ Final JSON to be sent:', JSON.stringify(requestData, null, 2))
      console.log('üöÄ === CLIENT SENDING REQUEST ===\n')
      
      console.log('üåê === MAKING FETCH REQUEST ===')
      console.log('URL:', '/api/chat')
      console.log('Method: POST')
      console.log('Headers:', { 'Content-Type': 'application/json' })
      console.log('Body (stringified):', JSON.stringify(requestData))
      
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestData),
      })

      console.log('üåê === RECEIVED RESPONSE ===')
      console.log('Response status:', response.status)
      console.log('Response ok:', response.ok)
      console.log('Response headers:', Object.fromEntries(response.headers.entries()))

      if (!response.ok) {
        let errorMessage = 'Failed to send message'
        try {
          const errorData = await response.json()
          console.error('üö® === API ERROR RESPONSE DETAILS ===')
          console.error('Full error data:', errorData)
          console.error('Error data keys:', Object.keys(errorData))
          console.error('Error response field:', errorData.response)
          console.error('Error success field:', errorData.success)
          console.error('Error model field:', errorData.model)
          
          if (errorData.response) {
            errorMessage = errorData.response
            console.error('üö® Using error message from server:', errorMessage)
          }
        } catch (parseError) {
          console.error('Error parsing API response:', parseError)
          errorMessage = `HTTP ${response.status}: ${response.statusText}`
        }
        throw new Error(errorMessage)
      }

      const data = await response.json()
      const assistantMessage: ChatMessage = {
        role: 'assistant',
        content: data.response,
        timestamp: new Date(),
      }

      setMessages(prev => [...prev, assistantMessage])
    } catch (error) {
      console.error('üö® Error sending message:', error)
      
      // Enhanced error handling with specific messages
      let errorContent = 'Sorry, I encountered an error. Please try again.'
      
      if (error instanceof Error) {
        console.error('üö® Chat error details:', error.message)
        console.error('üö® Full error object:', error)
        
        // Check for specific error types and use the actual error message when possible
        if (error.message.includes('Failed to send message')) {
          errorContent = '„ÉÅ„É£„ÉÉ„ÉàÊ©üËÉΩ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÂãïÁîª„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åã„ÇâË≥™Âïè„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
        } else if (error.message.includes('Network')) {
          errorContent = '„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇÊé•Á∂ö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ'
        } else if (error.message.includes('ÂãïÁîª„ÅÆÊñáÂ≠óËµ∑„Åì„Åó„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì')) {
          errorContent = error.message // Use the actual server error message
        } else if (error.message.includes('Failed to process chat message')) {
          errorContent = '„ÉÅ„É£„ÉÉ„ÉàÂá¶ÁêÜ‰∏≠„Å´„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„ÇâÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ'
        } else if (error.message.length > 10 && error.message.length < 200) {
          // If the error message seems reasonable, use it
          errorContent = error.message
        }
        
        // Log the final error content for debugging
        console.error('üö® Final error content to display:', errorContent)
      }
      
      const errorMessage: ChatMessage = {
        role: 'assistant',
        content: errorContent,
        timestamp: new Date(),
      }
      setMessages(prev => [...prev, errorMessage])
    } finally {
      setLoading(false)
    }
  }

  // Generate smart deep dive questions based on video content
  const generateSmartQuestions = () => {
    // Prioritize summary over transcript for better question generation
    const primaryContent = hasValidSummary ? safeSummary : ''
    const secondaryContent = hasValidTranscript ? safeTranscript : ''
    const title = videoTitle || ''
    
    const smartQuestions: string[] = []
    
    // Advanced content analysis
    const analyzedContent = analyzeContentForQuestions(primaryContent, secondaryContent, title)
    
    // Generate questions based on extracted insights
    smartQuestions.push(...analyzedContent.specificQuestions)
    smartQuestions.push(...analyzedContent.contextualQuestions)
    smartQuestions.push(...analyzedContent.deepDiveQuestions)
    
    // Remove duplicates and limit to 5 questions
    const uniqueQuestions = [...new Set(smartQuestions)]
    return uniqueQuestions.slice(0, 5)
  }

  // Advanced content analysis function - ensures questions are answerable from content
  const analyzeContentForQuestions = (summary: string, transcript: string, title: string) => {
    const specificQuestions: string[] = []
    const contextualQuestions: string[] = []
    const deepDiveQuestions: string[] = []
    
    // Use primary content (summary preferred, then transcript)
    const primaryContent = summary || transcript
    const secondaryContent = summary ? transcript : ''
    
    if (!primaryContent) {
      return { specificQuestions, contextualQuestions, deepDiveQuestions }
    }
    
    // Extract key entities and concepts from content
    const contentAnalysis = extractKeyEntities(primaryContent)
    
    // Generate specific questions only for concepts that are explained in the content
    contentAnalysis.concepts.forEach(concept => {
      if (concept.length > 2 && concept.length < 20) {
        // Only ask if the concept appears to be explained (has context around it)
        const conceptContext = findConceptContext(primaryContent, concept)
        if (conceptContext.isExplained) {
          specificQuestions.push(`${concept}„Å´„Å§„ÅÑ„Å¶„ÄÅÂãïÁîª„ÅßË™¨Êòé„Åï„Çå„Å¶„ÅÑ„ÅüÂÜÖÂÆπ„Çí„ÇÇ„ÅÜÂ∞ë„ÅóË©≥„Åó„ÅèÊïô„Åà„Å¶`)
        }
      }
    })
    
    // Generate questions for numbers that have context in the content
    contentAnalysis.numbers.forEach(number => {
      const numberContext = findNumberContext(primaryContent, number)
      if (numberContext.hasExplanation) {
        specificQuestions.push(`ÂãïÁîª„ÅßË®ÄÂèä„Åï„Çå„Å¶„ÅÑ„Åü„Äå${number}„Äç„Å´„Å§„ÅÑ„Å¶Ë©≥„Åó„ÅèË™¨Êòé„Åó„Å¶`)
      }
    })
    
    // Generate questions for methods that are actually described
    contentAnalysis.methods.forEach(method => {
      const methodContext = findMethodContext(primaryContent, method)
      if (methodContext.isDescribed) {
        specificQuestions.push(`ÂãïÁîª„ÅßÁ¥π‰ªã„Åï„Çå„Å¶„ÅÑ„Åü„Äå${method}„Äç„Å´„Å§„ÅÑ„Å¶Ë©≥„Åó„ÅèÊïô„Åà„Å¶`)
      }
    })
    
    // Generate contextual questions only for themes present in content
    if (contentAnalysis.hasResults && hasResultsDetails(primaryContent)) {
      contextualQuestions.push('ÂãïÁîª„ÅßÁ¥π‰ªã„Åï„Çå„Å¶„ÅÑ„ÅüÁµêÊûú„Å´„Å§„ÅÑ„Å¶„ÄÅ„Çà„ÇäË©≥„Åó„ÅèË™¨Êòé„Åó„Å¶')
    }
    
    if (contentAnalysis.hasComparison && hasComparisonDetails(primaryContent)) {
      contextualQuestions.push('ÂãïÁîª„ÅßÊØîËºÉ„Åï„Çå„Å¶„ÅÑ„ÅüÂÜÖÂÆπ„Å´„Å§„ÅÑ„Å¶„ÄÅÈÅï„ÅÑ„Çí„ÇÇ„Å£„Å®Ë©≥„Åó„ÅèÊïô„Åà„Å¶')
    }
    
    if (contentAnalysis.hasProcess && hasProcessDetails(primaryContent)) {
      contextualQuestions.push('ÂãïÁîª„ÅßË™¨Êòé„Åï„Çå„Å¶„ÅÑ„Åü„Éó„É≠„Çª„Çπ„ÅÆÈáçË¶Å„Å™„Éù„Ç§„É≥„Éà„ÇíÊïô„Åà„Å¶')
    }
    
    // Extract quotes and specific mentions that have enough context
    const quotes = extractMeaningfulQuotes(primaryContent)
    quotes.forEach(quote => {
      if (quote.length > 5 && quote.length < 30) {
        deepDiveQuestions.push(`ÂãïÁîª„Åß„Äå${quote}„Äç„Å®Ë®Ä„Å£„Å¶„ÅÑ„Åü„ÅÆ„ÅØ„Å©„ÅÜ„ÅÑ„ÅÜÊÑèÂë≥„Åß„Åô„ÅãÔºü`)
      }
    })
    
    // Generate questions about specific examples mentioned in the content
    const examples = extractExamples(primaryContent)
    examples.forEach(example => {
      deepDiveQuestions.push(`ÂãïÁîª„Åß‰æã„Å®„Åó„Å¶Êåô„Åí„Çâ„Çå„Å¶„ÅÑ„Åü„Äå${example}„Äç„Å´„Å§„ÅÑ„Å¶Ë©≥„Åó„ÅèÊïô„Åà„Å¶`)
    })
    
    // Only include title-based questions if the title content is actually discussed
    if (title && isTitleContentDiscussed(primaryContent, title)) {
      contextualQuestions.push(`ÂãïÁîª„ÅÆ„Çø„Ç§„Éà„É´„Äå${title}„Äç„Å´Èñ¢„Åô„ÇãÂÜÖÂÆπ„Åß„ÄÅÁâπ„Å´ÈáçË¶Å„Å†„Å®ÊÄù„ÅÜ„Éù„Ç§„É≥„Éà„ÅØÔºü`)
    }
    
    return { specificQuestions, contextualQuestions, deepDiveQuestions }
  }

  // Helper functions to validate content availability
  const findConceptContext = (content: string, concept: string) => {
    const conceptRegex = new RegExp(`${concept}(?:„Å®„ÅØ|„Å´„Å§„ÅÑ„Å¶|„Å´Èñ¢„Åó„Å¶|„Çí|„Åå|„ÅØ).{10,}`, 'g')
    const matches = content.match(conceptRegex)
    return { isExplained: matches && matches.length > 0 }
  }

  const findNumberContext = (content: string, number: string) => {
    const numberRegex = new RegExp(`${number}.{5,50}(?:ÁêÜÁî±|Ê†πÊã†|„Å™„Åú|„Å´„Å§„ÅÑ„Å¶|ÊÑèÂë≥|ÂäπÊûú|ÁµêÊûú)`, 'g')
    const matches = content.match(numberRegex)
    return { hasExplanation: matches && matches.length > 0 }
  }

  const findMethodContext = (content: string, method: string) => {
    const methodRegex = new RegExp(`${method}.{10,100}(?:ÊâãÈ†Ü|ÊñπÊ≥ï|„ÇÑ„ÇäÊñπ|„Çπ„ÉÜ„ÉÉ„Éó|„Éó„É≠„Çª„Çπ)`, 'g')
    const matches = content.match(methodRegex)
    return { isDescribed: matches && matches.length > 0 }
  }

  const hasResultsDetails = (content: string) => {
    return /ÁµêÊûú.{20,}|ÊàêÊûú.{20,}|ÂäπÊûú.{20,}/.test(content)
  }

  const hasComparisonDetails = (content: string) => {
    return /ÊØîËºÉ.{30,}|ÈÅï„ÅÑ.{20,}|ÂØæÊØî.{20,}/.test(content)
  }

  const hasProcessDetails = (content: string) => {
    return /ÊâãÈ†Ü.{30,}|„Çπ„ÉÜ„ÉÉ„Éó.{30,}|„Éó„É≠„Çª„Çπ.{30,}/.test(content)
  }

  const extractMeaningfulQuotes = (content: string) => {
    const quotes = content.match(/„Äå([^„Äç]{5,30})„Äç/g) || []
    return quotes.map(quote => quote.replace(/[„Äå„Äç]/g, ''))
      .filter(quote => {
        // Filter out common generic phrases
        const genericPhrases = ['„Åù„ÅÜ„Åß„Åô„Å≠', '„ÅØ„ÅÑ', '„ÅÇ„Çä„Åå„Å®„ÅÜ', '„Çà„Çç„Åó„Åè', '„Åä„Å§„Åã„Çå']
        return !genericPhrases.some(phrase => quote.includes(phrase))
      })
  }

  const extractExamples = (content: string) => {
    const examplePatterns = [
      /‰æã„Åà„Å∞([^„ÄÇ]{5,30})/g,
      /ÂÖ∑‰ΩìÁöÑ„Å´„ÅØ([^„ÄÇ]{5,30})/g,
      /ÂÆüÈöõ„Å´([^„ÄÇ]{5,30})/g
    ]
    
    const examples: string[] = []
    examplePatterns.forEach(pattern => {
      const matches = content.match(pattern)
      if (matches) {
        matches.forEach(match => {
          const example = match.replace(/(‰æã„Åà„Å∞|ÂÖ∑‰ΩìÁöÑ„Å´„ÅØ|ÂÆüÈöõ„Å´)/, '').trim()
          if (example.length > 3) {
            examples.push(example)
          }
        })
      }
    })
    
    return [...new Set(examples)]
  }

  const isTitleContentDiscussed = (content: string, title: string) => {
    // Check if title keywords appear with substantial discussion
    const titleWords = title.split(/[\s\-_]+/).filter(word => word.length > 2)
    return titleWords.some(word => {
      const wordRegex = new RegExp(`${word}.{50,}`, 'g')
      return wordRegex.test(content)
    })
  }

  // Extract key entities and patterns from content
  const extractKeyEntities = (content: string) => {
    const concepts: string[] = []
    const numbers: string[] = []
    const methods: string[] = []
    const specificMentions: string[] = []
    
    // Extract numbers and percentages
    const numberMatches = content.match(/\d+([.,]\d+)?[%ÔºÖÂÄãÂàÜÂÜÜÂπ¥ÊúàÊó•ÊôÇÈñìÁßíÂàÜ]/g)
    if (numberMatches) {
      numbers.push(...numberMatches.slice(0, 3))
    }
    
    // Extract method-related phrases
    const methodPatterns = [
      /([„Ç°-„É¥„Éº‰∏Ä-ÈæØa-zA-Z0-9]{3,})(ÊñπÊ≥ï|ÊâãÊ≥ï|„ÇÑ„ÇäÊñπ|„Ç¢„Éó„É≠„Éº„ÉÅ|ÊäÄË°ì|„ÉÜ„ÇØ„Éã„ÉÉ„ÇØ)/g,
      /(ÊñπÊ≥ï|ÊâãÊ≥ï|„ÇÑ„ÇäÊñπ|„Ç¢„Éó„É≠„Éº„ÉÅ|ÊäÄË°ì|„ÉÜ„ÇØ„Éã„ÉÉ„ÇØ)([„Ç°-„É¥„Éº‰∏Ä-ÈæØa-zA-Z0-9]{3,})/g
    ]
    
    methodPatterns.forEach(pattern => {
      const matches = content.match(pattern)
      if (matches) {
        methods.push(...matches.slice(0, 2))
      }
    })
    
    // Extract key concepts (nouns, technical terms)
    const conceptPatterns = [
      /([„Ç°-„É¥„Éº‰∏Ä-ÈæØ]{3,8})(„Å´„Å§„ÅÑ„Å¶|„Å´Èñ¢„Åó„Å¶|„Å®„ÅØ|„Åß„ÅÇ„Çã|„Åß„Åô)/g,
      /ÈáçË¶Å„Å™([„Ç°-„É¥„Éº‰∏Ä-ÈæØ]{3,8})/g,
      /([„Ç°-„É¥„Éº‰∏Ä-ÈæØ]{3,8})(„Çí|„Åå)(Ë™¨Êòé|Ëß£Ë™¨|Á¥π‰ªã|ÂÆüË£Ö|Â∞éÂÖ•)/g
    ]
    
    conceptPatterns.forEach(pattern => {
      const matches = content.match(pattern)
      if (matches) {
        matches.forEach(match => {
          const concept = match.replace(/(„Å´„Å§„ÅÑ„Å¶|„Å´Èñ¢„Åó„Å¶|„Å®„ÅØ|„Åß„ÅÇ„Çã|„Åß„Åô|„Çí|„Åå|Ë™¨Êòé|Ëß£Ë™¨|Á¥π‰ªã|ÂÆüË£Ö|Â∞éÂÖ•|ÈáçË¶Å„Å™)/g, '')
          if (concept.length > 2 && concept.length < 15) {
            concepts.push(concept)
          }
        })
      }
    })
    
    // Extract specific mentions and quotes
    const quotedContent = content.match(/„Äå([^„Äç]+)„Äç/g)
    if (quotedContent) {
      quotedContent.forEach(quote => {
        const cleaned = quote.replace(/[„Äå„Äç]/g, '')
        if (cleaned.length > 3 && cleaned.length < 30) {
          specificMentions.push(cleaned)
        }
      })
    }
    
    // Analyze content patterns
    const hasResults = /ÁµêÊûú|ÊàêÊûú|ÂäπÊûú|„Éá„Éº„Çø|Áµ±Ë®à/.test(content)
    const hasComparison = /ÊØîËºÉ|ÈÅï„ÅÑ|ÂØæÊØî|vs|„Å®ÊØî„Åπ„Å¶|„Å´ÂØæ„Åó„Å¶/.test(content)
    const hasProcess = /ÊâãÈ†Ü|„Çπ„ÉÜ„ÉÉ„Éó|„Éó„É≠„Çª„Çπ|ÊµÅ„Çå|ÊÆµÈöé/.test(content)
    
    return {
      concepts: [...new Set(concepts)],
      numbers: [...new Set(numbers)],
      methods: [...new Set(methods)],
      specificMentions: [...new Set(specificMentions)],
      hasResults,
      hasComparison,
      hasProcess
    }
  }

  const sampleQuestions = generateSmartQuestions()

  const handleSampleQuestionClick = (question: string) => {
    setInput(question)
  }

  return (
    <div className="bg-white rounded-lg shadow p-6 h-[600px] flex flex-col">
      <h2 className="text-lg font-medium text-gray-900 mb-4">Chat</h2>
      
      <div className="flex-1 overflow-y-auto mb-4 space-y-4">
        {messages.length === 0 ? (
          <div className="space-y-4">
            <p className="text-gray-500 text-center">
              {!hasAnyContentForUI ? "Upload a video first to start chatting..." : "Start a conversation about the video..."}
            </p>
            
            {/* Sample Deep Dive Questions - only show when we have transcript/summary */}
            {hasAnyContentForUI && (
              <div className="bg-gray-50 rounded-lg p-3 border border-gray-200">
                <h3 className="text-xs font-medium text-gray-600 mb-2">üí° Ë≥™Âïè„Çµ„É≥„Éó„É´</h3>
                <div className="flex flex-wrap gap-1">
                  {sampleQuestions.slice(0, 3).map((question, index) => (
                    <span
                      key={index}
                      onClick={() => handleSampleQuestionClick(question)}
                      className="bg-blue-100 hover:bg-blue-200 text-blue-800 px-2 py-1 text-xs rounded cursor-pointer transition-colors"
                      title="„ÇØ„É™„ÉÉ„ÇØ„Åß„ÉÅ„É£„ÉÉ„Éà„Å´Ë≥™Âïè„ÇíÂÖ•Âäõ"
                    >
                      {question}
                    </span>
                  ))}
                </div>
                <p className="text-xs text-gray-500 mt-1">Ë≥™Âïè„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Á∞°Âçò„Å´Ê∑±Êéò„ÇäÔºÅ</p>
              </div>
            )}
          </div>
        ) : (
          messages.map((message, index) => (
            <div
              key={index}
              className={`flex ${message.role === 'user' ? 'justify-end' : 'justify-start'}`}
            >
              <div
                className={`max-w-4xl px-4 py-3 rounded-lg ${
                  message.role === 'user'
                    ? 'bg-gray-700 text-white'
                    : 'bg-gray-100 text-gray-900'
                }`}
              >
                {message.role === 'assistant' ? (
                  <MarkdownRenderer content={message.content} className="text-base" />
                ) : (
                  <p className="text-base leading-relaxed whitespace-pre-wrap">{message.content}</p>
                )}
                <p className={`text-xs mt-2 ${
                  message.role === 'user' ? 'text-white opacity-75' : 'text-gray-500'
                }`}>
                  {message.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          ))
        )}
        {loading && (
          <div className="flex justify-start">
            <div className="bg-gray-100 text-gray-900 max-w-4xl px-4 py-3 rounded-lg">
              <div className="flex items-center space-x-2">
                <div className="loading" />
                <span className="text-base">Thinking...</span>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>
      

      <form onSubmit={sendMessage} className="flex space-x-2">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder={!hasAnyContentForUI ? "Upload a video first to start chatting..." : "Ask about the video..."}
          className="flex-1 border-gray-300 rounded-md shadow-sm focus:ring-gray-500 focus:border-gray-500 text-base px-4 py-2"
          disabled={loading || !hasAnyContentForUI}
        />
        <button
          type="submit"
          disabled={loading || !input.trim() || !hasAnyContentForUI}
          className="px-6 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500 disabled:opacity-50 text-base"
        >
          Send
        </button>
      </form>
    </div>
  )
}

export default ChatInterface