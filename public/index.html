<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube 文字起こし & チャット</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            font-size: 16px;
            line-height: 1.6;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            height: 100vh;
            overflow: hidden;
        }
        .app-header {
            text-align: center;
            padding: 1rem 0;
            color: white;
            margin-bottom: 1rem;
        }
        .app-header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .app-header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        .section {
            background: white;
            border-radius: 16px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .section h2 {
            margin: 0 0 1rem 0;
            color: #2d3748;
            font-size: 1.3rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .section-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8rem;
        }
        input, textarea, select {
            width: 100%;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 1rem;
            background: #f8fafc;
            transition: all 0.3s ease;
            font-family: inherit;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin: 0.5rem 0;
            font-family: inherit;
        }
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .transcript {
            background: #f9f9f9;
            border-left: 4px solid #007cba;
            padding: 15px;
            margin: 10px 0;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .chat-messages {
            height: 100%;
            overflow-y: auto;
            background: transparent;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 transparent;
        }
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        .chat-messages::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        .message {
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            border-radius: 12px;
            max-width: 90%;
            animation: fadeIn 0.3s ease;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .user-message {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        .ai-message {
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            color: #2d3748;
            margin-right: auto;
            white-space: normal;
            word-wrap: break-word;
            line-height: 1.6;
        }
        
        /* AIメッセージ内のMarkdown要素のスタイル */
        .ai-message h1, .ai-message h2, .ai-message h3, .ai-message h4, .ai-message h5, .ai-message h6 {
            margin: 0.5rem 0;
            color: #1a202c;
        }
        .ai-message p {
            margin: 0.5rem 0;
        }
        .ai-message ul, .ai-message ol {
            margin: 0.5rem 0;
            padding-left: 1.5rem;
        }
        .ai-message li {
            margin: 0.25rem 0;
        }
        .ai-message code {
            background: rgba(102, 126, 234, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.85em;
        }
        .ai-message pre {
            background: #f8fafc;
            padding: 0.75rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
            overflow-x: auto;
            margin: 0.5rem 0;
        }
        .ai-message pre code {
            background: none;
            padding: 0;
        }
        .ai-message blockquote {
            border-left: 4px solid #667eea;
            padding-left: 1rem;
            margin: 0.5rem 0;
            color: #4a5568;
            font-style: italic;
        }
        .ai-message strong {
            font-weight: 600;
            color: #2d3748;
        }
        .ai-message em {
            font-style: italic;
            color: #4a5568;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        .error {
            color: #dc3545;
            background: #f8d7da;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success {
            color: #155724;
            background: #d4edda;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .costs-display {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            padding: 1.5rem;
            border-radius: 16px;
            border: 2px solid #e2e8f0;
            backdrop-filter: blur(10px);
        }
        .video-player-container {
            margin-bottom: 1rem;
            border-radius: 12px;
            overflow: hidden;
            background: #000;
            position: relative;
            padding-bottom: 56.25%; /* 16:9の標準比率 */
            height: 0;
            width: 100%;
            transition: all 0.3s ease;
        }
        
        .video-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #dee2e6;
            overflow: visible; /* はみ出しを許可 */
            position: relative;
        }
        .video-player-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        .timestamp-link {
            color: #667eea;
            cursor: pointer;
            text-decoration: underline;
            font-weight: 600;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        .timestamp-link:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.05);
        }
        .timestamp-segment {
            margin: 0 !important;
            padding: 0 !important;
            transition: all 0.3s ease;
            display: block;
            line-height: 1;
        }
        .timestamp-row {
            display: flex;
            align-items: center;
            padding: 2px 4px !important;
            border-radius: 3px;
            transition: all 0.3s ease;
            height: 18px !important;
            min-height: 18px !important;
            max-height: 18px !important;
            overflow: hidden;
            margin: 0;
        }
        .timestamp-row:hover {
            background: rgba(102, 126, 234, 0.08);
        }
        .timestamp-segment.current-segment .timestamp-row {
            background: rgba(102, 126, 234, 0.2);
            border-left: 2px solid #667eea;
            padding-left: 6px !important;
        }
        .timestamp-time {
            min-width: 45px;
            width: 45px;
            font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
            font-size: 0.7rem;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            margin-right: 6px;
            text-align: right;
            padding: 0;
            border-radius: 2px;
            transition: all 0.3s ease;
            flex-shrink: 0;
            line-height: 1;
        }
        .timestamp-time:hover {
            background: rgba(102, 126, 234, 0.1);
            transform: scale(1.05);
        }
        .timestamp-text {
            flex: 1;
            line-height: 1 !important;
            color: #2d3748;
            font-size: 0.8rem;
            margin: 0;
            padding: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .timestamp-transcript {
            font-family: inherit;
            line-height: 1 !important;
            padding: 0 !important;
            margin: 0 !important;
        }
        .ai-message {
            background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
            color: #2d3748;
            margin-right: auto;
        }
        .ai-message .timestamp-link {
            background: rgba(102, 126, 234, 0.15);
            color: #667eea;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            text-decoration: none;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        .ai-message .timestamp-link:hover {
            background: rgba(102, 126, 234, 0.25);
            color: #5a67d8;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.2);
        }
        .cost-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-family: monospace;
        }
        .total-cost {
            border-top: 2px solid #007cba;
            padding-top: 8px;
            font-weight: bold;
            font-size: 1.1em;
        }
        .costs-tabs {
            display: flex;
            background: #f8fafc;
            border-radius: 8px;
            padding: 2px;
            margin-bottom: 1rem;
        }
        .costs-tab-button {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-weight: 600;
        }
        .costs-tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        .costs-tab-button:not(.active) {
            color: #718096;
            opacity: 0.7;
        }
        .costs-tab-button:not(.active):hover {
            background: #e2e8f0;
            opacity: 1;
        }
        .costs-tab-content {
            display: none;
        }
        .costs-tab-content.active {
            display: block;
        }
        .costs-filter {
            margin-bottom: 1rem;
        }
        .costs-filter select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid #e2e8f0;
        }
        .costs-analysis-summary {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
        }
        .costs-chart {
            background: white;
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            margin-bottom: 1rem;
        }
        .history-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            background: #fafafa;
        }
        .history-item {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 16px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        .history-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            background: linear-gradient(135deg, #ffffff, #f1f5f9);
        }
        .history-title {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }
        .history-meta {
            font-size: 0.9em;
            color: #666;
            display: flex;
            justify-content: space-between;
        }
        .history-channel {
            font-size: 0.9em;
            color: #666;
            margin: 3px 0;
        }
        .history-url {
            font-size: 0.85em;
            margin: 3px 0;
        }
        .history-url a {
            color: #007cba;
            text-decoration: none;
        }
        .history-url a:hover {
            text-decoration: underline;
        }
        
        /* 履歴タブとフィルター */
        .history-controls {
            margin-bottom: 1rem;
        }
        
        .history-tabs {
            display: flex;
            background: #f8fafc;
            border-radius: 8px;
            padding: 2px;
            margin-bottom: 1rem;
        }
        
        .history-tab-button {
            flex: 1;
            padding: 0.5rem;
            background: transparent;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .history-tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }
        
        .history-tab-button:not(.active) {
            color: #718096;
            opacity: 0.7;
        }
        
        .history-tab-button:not(.active):hover {
            background: #e2e8f0;
            opacity: 1;
        }
        
        /* タグ表示 */
        .video-tags {
            margin: 0.5rem 0;
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }
        
        .tag-item {
            background: linear-gradient(135deg, #ebf8ff, #e6fffa);
            color: #2d3748;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.75rem;
            border: 1px solid #bee3f8;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tag-item:hover {
            background: linear-gradient(135deg, #bee3f8, #81e6d9);
            transform: translateY(-1px);
        }
        
        .suggestion-tag {
            background: #f7fafc;
            color: #4a5568;
            padding: 0.25rem 0.5rem;
            border-radius: 8px;
            font-size: 0.75rem;
            cursor: pointer;
            margin: 0.125rem;
            display: inline-block;
            transition: all 0.3s ease;
        }
        
        .suggestion-tag:hover {
            background: #667eea;
            color: white;
        }
        
        /* フォルダサジェスチョン */
        .folder-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        .folder-suggestion-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .folder-suggestion-item:last-child {
            border-bottom: none;
        }
        
        .folder-suggestion-item:hover {
            background: linear-gradient(135deg, #ebf8ff, #e6fffa);
            color: #2d3748;
        }
        
        .folder-suggestion-item .folder-icon {
            color: #667eea;
            font-size: 1rem;
        }
        
        .folder-suggestion-item .folder-name {
            font-weight: 600;
            flex: 1;
        }
        
        .folder-suggestion-item .folder-count {
            font-size: 0.8rem;
            color: #666;
            background: #f1f5f9;
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
        }
        
        /* グループ化された履歴 */
        .history-group {
            margin-bottom: 1.5rem;
        }
        
        .history-group-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 12px 12px 0 0;
            font-weight: 600;
            font-size: 0.9rem;
        }
        
        .history-group-items {
            background: #f8fafc;
            border-radius: 0 0 12px 12px;
            padding: 0.5rem;
        }
        
        .history-group-items .history-item {
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }
        
        /* 選択されたメインタグ */
        .selected-tag {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .selected-tag:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .selected-tag .remove-tag {
            cursor: pointer;
            font-weight: bold;
            padding: 0.125rem 0.25rem;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .selected-tag .remove-tag:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        /* アコーディオン機能 */
        .history-group-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 12px;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .history-group-header:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }
        
        .history-group-header .toggle-icon {
            font-size: 0.8rem;
            transition: transform 0.3s ease;
        }
        
        .history-group.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        .history-group-items {
            background: #f8fafc;
            border-radius: 0 0 12px 12px;
            padding: 0.5rem;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .history-group.collapsed .history-group-items {
            display: none;
        }
        .method-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .method-subtitle {
            background: linear-gradient(135deg, #48bb78, #38a169);
            color: white;
        }
        .method-whisper {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }
        .language-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            background: linear-gradient(135deg, #a0aec0, #718096);
            color: white;
            margin-left: 0.5rem;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        .info-item {
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .chapters-info {
            margin-top: 15px;
            padding: 10px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .chapter-item {
            padding: 5px 0;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }
        .chapter-item:hover {
            background: #f8f9fa;
        }
        .chapter-timestamp {
            font-weight: bold;
            color: #007cba;
            margin-right: 10px;
        }
        .summary {
            background: linear-gradient(135deg, #f0fff4, #ffffff);
            border-left: 4px solid #48bb78;
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1rem 0;
            max-height: 500px;
            overflow-y: auto;
            font-size: 1rem;
            line-height: 1.6;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 transparent;
        }
        .summary::-webkit-scrollbar {
            width: 6px;
        }
        .summary::-webkit-scrollbar-track {
            background: transparent;
        }
        .summary::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        .summary h2 {
            color: #28a745;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        .summary h3 {
            color: #155724;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        .summary ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        .summary li {
            margin-bottom: 5px;
        }
        .summary p {
            margin: 10px 0;
        }
        .summary code {
            background: #e9ecef;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        .suggested-questions {
            margin-bottom: 0.3rem;
            padding: 0.3rem;
            background: linear-gradient(135deg, #ebf8ff, #e6fffa);
            border-radius: 8px;
            border: 1px solid #bee3f8;
            max-height: 80px;
            overflow-y: auto;
            flex-shrink: 0;
        }
        .question-item {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            padding: 0.2rem 0.4rem;
            margin: 0.1rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.75rem;
            line-height: 1.2;
        }
        .question-item:hover {
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            border-color: #667eea;
            transform: translateX(4px);
        }
        .transcript {
            background: linear-gradient(135deg, #f8fafc, #ffffff);
            border-left: 4px solid #667eea;
            border-radius: 16px;
            padding: 1.5rem;
            margin: 1rem 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 500px;
            overflow-y: auto;
            font-size: 1rem;
            line-height: 1.8;
        }
        
        /* 記事コンテンツのスタイル */
        .article-content h1 {
            font-size: 2rem;
            font-weight: 700;
            color: #1a202c;
            margin: 2rem 0 1.5rem 0;
            padding-bottom: 0.75rem;
            border-bottom: 3px solid #667eea;
        }
        
        .article-content h2 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2d3748;
            margin: 2rem 0 1rem 0;
            padding: 0.75rem 0;
            border-bottom: 2px solid #e2e8f0;
            position: relative;
        }
        
        .article-content h2::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: #667eea;
        }
        
        .article-content h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #4a5568;
            margin: 1.5rem 0 0.75rem 0;
            padding-left: 1rem;
            border-left: 4px solid #667eea;
            background: linear-gradient(135deg, #f7fafc, #edf2f7);
            padding: 0.5rem 1rem;
            border-radius: 0 8px 8px 0;
        }
        
        .article-content p {
            margin: 1rem 0;
            color: #4a5568;
            line-height: 1.8;
        }
        
        .article-content ul, .article-content ol {
            margin: 1rem 0;
            padding-left: 1.5rem;
        }
        
        .article-content li {
            margin: 0.5rem 0;
            color: #4a5568;
            line-height: 1.6;
        }
        
        .article-content strong {
            color: #2d3748;
            font-weight: 600;
        }
        
        .article-content code {
            background: #f7fafc;
            color: #667eea;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .article-content blockquote {
            border-left: 4px solid #667eea;
            background: linear-gradient(135deg, #f0f4ff, #e0e7ff);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
            font-style: italic;
            color: #4c1d95;
        }
            font-family: 'Hiragino Sans', 'Yu Gothic', sans-serif;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 transparent;
        }
        .transcript::-webkit-scrollbar {
            width: 6px;
        }
        .transcript::-webkit-scrollbar-track {
            background: transparent;
        }
        .transcript::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }
        .controls-row {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        .language-selector,
        .model-selector {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
        }
        .language-selector label,
        .model-selector label {
            font-weight: 600;
            color: #2d3748;
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        .language-selector select,
        .model-selector select {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .language-selector select:focus,
        .model-selector select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .chat-input-container {
            display: flex;
            gap: 0.75rem;
            align-items: flex-end;
        }
        .chat-input-container input,
        .chat-input-container textarea {
            flex: 1;
            margin: 0;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            font-family: inherit;
            line-height: 1.4;
        }
        .chat-input-container button {
            width: auto;
            min-width: 80px;
            margin: 0;
        }
        
        /* Responsive Design */
        @media (min-width: 768px) {
            .container {
                padding: 2rem;
            }
            .controls-row {
                grid-template-columns: 1fr 1fr;
            }
            .app-header h1 {
                font-size: 3rem;
            }
            .section {
                padding: 2rem;
            }
        }
        @media (min-width: 1024px) {
            .controls-row {
                grid-template-columns: 1fr 1fr;
                gap: 2rem;
            }
        }
        
        /* 新しいレイアウト用CSS */
        .main-content {
            display: flex;
            gap: 0;
            max-width: 100vw;
            margin: 0 auto;
            padding: 1rem;
            height: calc(100vh - 200px);
        }
        
        .left-panel {
            height: 100%;
            overflow-y: auto;
            width: 350px;
            transition: width 0.3s ease;
            flex-shrink: 0;
        }
        
        .left-panel .section {
            overflow-y: auto;
            position: relative;
            transition: all 0.3s ease;
            max-height: calc(100vh - 280px);
        }
        
        /* レサイザー */
        .resize-handle {
            position: relative;
            width: 16px;
            height: 100%;
            cursor: col-resize;
            background: #667eea;
            border-radius: 4px;
            opacity: 0.7;
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 4px;
            flex-shrink: 0;
        }
        
        .resize-handle:hover {
            background: #764ba2;
            opacity: 1;
        }
        
        .resize-handle::before {
            content: '⋮⋮';
            color: white;
            font-size: 14px;
            line-height: 1;
            transform: rotate(90deg);
        }
        
        .right-panel {
            flex: 1;
            height: 100%;
            display: flex;
            flex-direction: column;
            min-width: 400px;
        }
        
        .content-tabs {
            display: flex;
            background: #f8fafc;
            border-radius: 12px;
            padding: 4px;
            margin-bottom: 1rem;
        }
        
        .tab-button {
            flex: 1;
            padding: 1rem;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 0.85rem;
            text-align: center;
            line-height: 1.2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
            min-height: 60px;
            color: #4a5568;
        }
        
        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            border-color: #667eea;
        }
        
        .tab-button:not(.active):hover {
            background: #e2e8f0;
            border-color: #cbd5e0;
            transform: translateY(-1px);
        }
        
        .tab-content {
            display: none;
            height: 500px;
            overflow-y: auto;
            background: white;
            border-radius: 12px;
            padding: 0.5rem;
            border: 2px solid #e2e8f0;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .chat-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            margin-top: 1rem;
            min-height: 500px;
            max-height: 600px;
            height: auto;
            overflow: hidden;
            position: relative;
        }
        
        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid #e2e8f0;
            background: linear-gradient(135deg, #f8fafc, #ffffff);
            border-radius: 10px 10px 0 0;
            flex-shrink: 0;
        }
        
        .chat-messages-panel {
            flex: 1;
            padding: 1rem;
            padding-bottom: 100px;
            overflow-y: auto;
            min-height: 300px;
            max-height: 420px;
        }
        
        .chat-input-panel {
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            background: #f8fafc;
            border-radius: 0 0 10px 10px;
            flex-shrink: 0 !important;
            min-height: 80px !important;
            height: auto !important;
            position: absolute !important;
            bottom: 0 !important;
            left: 0 !important;
            right: 0 !important;
            z-index: 100 !important;
            display: flex !important;
            visibility: visible !important;
        }
        
        .chat-input-container {
            display: flex !important;
            gap: 0.75rem;
            align-items: center;
            width: 100% !important;
        }
        
        .chat-input-container input,
        .chat-input-container textarea {
            flex: 1;
            margin: 0;
            display: block !important;
            visibility: visible !important;
            width: auto !important;
            min-width: 200px;
        }
        
        .chat-input-container button {
            width: auto;
            min-width: 80px;
            margin: 0;
            display: block !important;
            visibility: visible !important;
        }
        
        /* Mobile-first improvements */
        @media (max-width: 1200px) {
            .main-content {
                flex-direction: column;
                gap: 1rem;
                height: auto;
            }
            
            .left-panel {
                width: 100%;
                height: auto;
                max-height: 400px;
            }
            
            .right-panel {
                position: static;
                height: auto;
                min-height: 600px;
            }
            
            .chat-panel {
                min-height: 400px;
                max-height: 550px;
            }
            
            .chat-messages-panel {
                min-height: 200px;
                max-height: 320px;
            }
        }
        
        @media (max-width: 767px) {
            .app-header h1 {
                font-size: 2rem;
            }
            .section {
                padding: 1rem;
                margin-bottom: 1rem;
            }
            .message {
                max-width: 95%;
            }
            .main-content {
                padding: 0.5rem;
            }
            
            .chat-input-container {
                gap: 0.5rem;
            }
            
            .chat-input-container input,
            .chat-input-container textarea {
                font-size: 16px; /* iOSでズームインを防ぐ */
            }
        }
        
        /* 記事マークダウン用スタイル */
        .article-markdown {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.7;
        }
        
        .article-markdown h1 {
            color: #1a202c;
            font-size: 1.75rem;
            font-weight: 700;
            margin: 0 0 1rem 0;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 0.5rem;
        }
        
        .article-markdown h2 {
            color: #2d3748;
            font-size: 1.4rem;
            font-weight: 600;
            margin: 1.5rem 0 1rem 0;
        }
        
        .article-markdown h3 {
            color: #4a5568;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 1.25rem 0 0.75rem 0;
        }
        
        .article-markdown p {
            margin: 0 0 1rem 0;
            color: #2d3748;
        }
        
        .article-markdown code {
            background: #f7fafc;
            color: #e53e3e;
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9rem;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }
        
        .article-markdown pre {
            background: #1a202c;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            overflow-x: auto;
            margin: 1rem 0;
        }
        
        .article-markdown pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        
        .article-markdown ul, .article-markdown ol {
            margin: 0 0 1rem 0;
            padding-left: 1.5rem;
        }
        
        .article-markdown li {
            margin: 0.25rem 0;
        }
        
        .article-markdown blockquote {
            border-left: 4px solid #667eea;
            padding-left: 1rem;
            margin: 1rem 0;
            color: #4a5568;
            font-style: italic;
        }
        
        .article-markdown strong {
            font-weight: 600;
            color: #1a202c;
        }
        
        /* アコーディオンスタイル */
        .costs-accordion {
            margin: 1rem 0;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .accordion-header {
            background: #f8fafc;
            padding: 0.75rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #4a5568;
            transition: background-color 0.3s ease;
        }
        
        .accordion-header:hover {
            background: #e2e8f0;
        }
        
        .accordion-arrow {
            font-size: 0.8rem;
        }
        
        /* 汎用メッセージ表示 */
        .message-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 9999;
            max-width: 400px;
        }
        
        .message-item {
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            animation: slideInRight 0.3s ease;
        }
        
        .message-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .message-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .message-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
            transition: transform 0.3s ease;
        }
        
        .accordion-arrow.expanded {
            transform: rotate(180deg);
        }
        
        .accordion-content {
            padding: 1rem;
            background: white;
            border-top: 1px solid #e2e8f0;
        }
        
    </style>
</head>
<body>
    <!-- 汎用メッセージ表示コンテナ -->
    <div id="messageContainer" class="message-container"></div>
    
    <div class="app-header">
        <h1>🎥 YouTube AI Assistant</h1>
        <p>動画を文字起こしして、AIと対話しよう</p>
    </div>
    
    <div class="section">
        <h2><span class="section-icon">📥</span>YouTube動画をアップロード</h2>
        <div class="input-group">
            <div class="main-tags-container">
                <label for="mainTags" style="font-weight: 600; color: #2d3748; display: block; margin-bottom: 0.5rem;">🏷️ メインタグ (カンマ区切り):</label>
                <input type="text" id="mainTags" placeholder="例: 商談, プロジェクト, 学習資料" 
                       style="width: 100%; padding: 0.75rem; border-radius: 8px; border: 2px solid #e2e8f0; margin-bottom: 0.5rem;"
                       oninput="showMainTagSuggestions(this.value)" onfocus="showMainTagSuggestions(this.value)">
                <div class="main-tag-suggestions" id="mainTagSuggestions" style="display: none; position: relative; z-index: 100;">
                    <div class="suggestion-list" style="background: white; border: 1px solid #e2e8f0; border-radius: 8px; max-height: 150px; overflow-y: auto; box-shadow: 0 4px 12px rgba(0,0,0,0.15);"></div>
                </div>
                <div class="selected-main-tags" id="selectedMainTags" style="margin-top: 0.5rem; display: flex; flex-wrap: wrap; gap: 0.25rem;"></div>
            </div>
            <input type="text" id="youtubeUrl" list="urlHistory" placeholder="YouTubeのURLを入力してください">
            <datalist id="urlHistory">
                <!-- URL history will be populated dynamically -->
            </datalist>
            <div class="controls-row">
                <div class="language-selector">
                    <label for="languageSelect">文字起こし言語:</label>
                    <select id="languageSelect">
                        <option value="original" selected>Original (自動判定)</option>
                        <option value="ja">日本語</option>
                        <option value="en">English</option>
                    </select>
                </div>
                <div class="model-selector">
                    <label for="gptModelSelect">GPTモデル:</label>
                    <select id="gptModelSelect">
                        <option value="gpt-4o-mini">GPT-4o-mini - $0.60/$2.40 per 1M tokens</option>
                        <option value="gpt-4o">GPT-4o (高品質) - $5.00/$15.00 per 1M tokens</option>
                        <option value="gpt-4-turbo">GPT-4-turbo (最高品質) - $10.00/$30.00 per 1M tokens</option>
                        <option value="gpt-3.5-turbo">GPT-3.5-turbo (高速・低コスト) - $0.50/$1.50 per 1M tokens</option>
                        <option value="gpt-4.1-nano">GPT-4.1-nano (超高速) - $0.10/$0.40 per 1M tokens</option>
                        <option value="gpt-4.1-mini" selected>GPT-4.1-mini (推奨) - $0.40/$1.60 per 1M tokens</option>
                        <option value="gpt-4.1">GPT-4.1 (最新) - $2.00/$8.00 per 1M tokens</option>
                        <option value="gpt-o3">GPT-o3 (推論強化) - $2.00/$8.00 per 1M tokens</option>
                        <option value="gpt-4o-mini-new">GPT-4o-mini (新) - $1.10/$4.40 per 1M tokens</option>
                    </select>
                </div>
            </div>
        </div>
        <button id="uploadBtn" onclick="uploadYouTube()">解析開始</button>
        <div id="uploadStatus"></div>
        
    </div>

    <div class="main-content">
        <div class="left-panel">
            <div class="section">
                <h2><span class="section-icon">📊</span>動画情報</h2>
                <div id="videoInfo" class="video-info" style="display: none;">
                    <div class="video-player-container" id="videoPlayerContainer" style="display: none;">
                        <div id="youtubePlayer"></div>
                    </div>
                    <div class="info-grid" style="grid-template-columns: 1fr; gap: 5px; font-size: 0.85rem;">
                        <div class="info-item" style="padding: 5px 8px;">
                            <strong>タイトル:</strong> <span id="videoTitle">-</span>
                        </div>
                        <div class="info-item" style="padding: 5px 8px;">
                            <strong>チャンネル:</strong> <span id="videoChannel">-</span>
                        </div>
                        <div class="info-item" style="padding: 5px 8px;">
                            <strong>時間:</strong> <span id="videoDuration">-</span> | <strong>再生回数:</strong> <span id="videoViews">-</span>
                        </div>
                        <div class="info-item" style="padding: 5px 8px;">
                            <strong>処理方法:</strong> <span id="processingMethod">-</span>
                        </div>
                    </div>
                    <div id="chaptersInfo" class="chapters-info" style="display: none;">
                        <h4>📋 チャプター情報</h4>
                        <div id="chaptersList"></div>
                    </div>
                </div>
            </div>

            <div class="section">
                <h2><span class="section-icon">💰</span>使用料金</h2>
                
                <div class="costs-tabs">
                    <button class="costs-tab-button active" onclick="switchCostsTab('analysis')">分析</button>
                    <button class="costs-tab-button" onclick="switchCostsTab('graph')">グラフ</button>
                </div>
                
                <div id="analysisCosts" class="costs-tab-content active">
                    <div class="costs-filter">
                        <select id="periodSelect" onchange="loadCostsAnalysis()" style="width: 100%; padding: 0.5rem; margin-bottom: 1rem; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <option value="session" selected>セッション</option>
                            <option value="today">本日</option>
                            <option value="week">週間</option>
                            <option value="month">月間</option>
                        </select>
                    </div>
                    <div id="costsAnalysisResult">
                        <!-- 料金分析情報がここに表示されます -->
                    </div>
                </div>
                
                <div id="graphCosts" class="costs-tab-content">
                    <div class="costs-filter">
                        <select id="graphPeriodSelect" onchange="loadCostsGraph()" style="width: 100%; padding: 0.5rem; margin-bottom: 1rem; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <option value="today" selected>本日</option>
                            <option value="week">週間</option>
                            <option value="month">月間</option>
                        </select>
                    </div>
                    <div id="costsGraphResult">
                        <canvas id="costsChart" width="300" height="200"></canvas>
                    </div>
                </div>
            </div>

<div class="section">
                <h2><span class="section-icon">📚</span>履歴</h2>
                
                <div class="history-controls">
                    <div class="history-tabs">
                        <button class="history-tab-button active" onclick="switchHistoryTab('timeline')">時間軸</button>
                        <button class="history-tab-button" onclick="switchHistoryTab('channel')">チャンネル別</button>
                        <button class="history-tab-button" onclick="switchHistoryTab('tag')">タグ別</button>
                    </div>
                    
                    <div class="history-filters">
                        <select id="historyFilter" onchange="filterHistory()" style="width: 100%; padding: 0.5rem; margin: 0.5rem 0; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <option value="all">すべて</option>
                            <option value="today">本日</option>
                            <option value="week">過去7日</option>
                            <option value="month">過去30日</option>
                        </select>
                        
                        <input type="text" id="historySearch" placeholder="検索..." 
                               style="width: 100%; padding: 0.5rem; margin: 0.5rem 0; border-radius: 6px; border: 1px solid #e2e8f0;"
                               oninput="searchHistory()">
                    </div>
                </div>
                
                <div id="historyList" class="history-list">
                    履歴を読み込み中...
                </div>
                <button onclick="loadHistory()" id="refreshHistoryBtn">履歴を更新</button>
            </div>
        </div>
        <div class="resize-handle" id="resizeHandle"></div>
        <div class="right-panel">
            <div class="content-tabs">
                <button class="tab-button active" onclick="switchTab('summary')">
                    <span style="font-size: 1.5rem;">📝</span>
                    <span>要約</span>
                </button>
                <button class="tab-button" onclick="switchTab('transcript')">
                    <span style="font-size: 1.5rem;">📋</span>
                    <span>文字起こし</span>
                </button>
                <button class="tab-button" onclick="switchTab('article')">
                    <span style="font-size: 1.5rem;">✍️</span>
                    <span>解説記事</span>
                </button>
            </div>
            
            <div id="summaryTab" class="tab-content active">
                <!-- プロンプト設定セクション -->
                <div class="prompt-settings" style="margin-bottom: 1rem;">
                    <div class="prompt-toggle" onclick="togglePromptSettings('summary')" style="cursor: pointer; padding: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #4a5568;">⚙️ 要約プロンプト設定</span>
                        <span id="summaryPromptArrow" class="prompt-arrow">▼</span>
                    </div>
                    <div id="summaryPromptSettings" class="prompt-content" style="display: none; margin-top: 0.5rem; padding: 1rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
                        <div style="margin-bottom: 1rem;">
                            <label style="font-weight: 600; color: #4a5568; display: block; margin-bottom: 0.5rem;">カスタムプロンプト:</label>
                            <textarea id="summaryPromptText" rows="10" placeholder="デフォルトプロンプトが表示されています。編集して保存できます。"
                                      style="width: 100%; font-family: monospace; font-size: 0.85rem; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; resize: vertical;"></textarea>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <button onclick="savePrompt('summary')" style="margin-right: 0.5rem; padding: 0.5rem 1rem; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">💾 保存</button>
                            <button onclick="resetPrompt('summary')" style="padding: 0.5rem 1rem; background: #f56565; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">🔄 デフォルトに戻す</button>
                        </div>
                        <div id="summaryPromptMessage" style="display: none; padding: 0.75rem; border-radius: 6px; font-size: 0.9rem; margin-bottom: 0.5rem;"></div>
                    </div>
                </div>
                
                <!-- 要約再生成ボタン -->
                <div id="summaryRegenerateSection" style="display: none; margin-bottom: 0.5rem; padding: 0.4rem 0.6rem; background: #fef5e7; border: 1px solid #f6ad55; border-radius: 6px;">
                    <button onclick="regenerateContent('summary')" id="regenerateSummaryOnlyBtn" 
                            style="background: #38a169; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.8rem; transition: all 0.3s ease;" 
                            onmouseover="this.style.background='#2f855a'" 
                            onmouseout="this.style.background='#38a169'">
                        📋 要約を再解析
                    </button>
                </div>
                
                <div id="summary" class="summary">
                    要約がここに表示されます...
                </div>
            </div>
            
            <div id="articleTab" class="tab-content">
                <!-- プロンプト設定セクション -->
                <div class="prompt-settings" style="margin-bottom: 1rem;">
                    <div class="prompt-toggle" onclick="togglePromptSettings('article')" style="cursor: pointer; padding: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: #4a5568;">⚙️ 解説記事プロンプト設定</span>
                        <span id="articlePromptArrow" class="prompt-arrow">▼</span>
                    </div>
                    <div id="articlePromptSettings" class="prompt-content" style="display: none; margin-top: 0.5rem; padding: 1rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
                        <div style="margin-bottom: 1rem;">
                            <label style="font-weight: 600; color: #4a5568; display: block; margin-bottom: 0.5rem;">カスタムプロンプト:</label>
                            <textarea id="articlePromptText" rows="10" placeholder="デフォルトプロンプトが表示されています。編集して保存できます。"
                                      style="width: 100%; font-family: monospace; font-size: 0.85rem; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; resize: vertical;"></textarea>
                        </div>
                        <div style="margin-bottom: 1rem;">
                            <button onclick="savePrompt('article')" style="margin-right: 0.5rem; padding: 0.5rem 1rem; background: #48bb78; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">💾 保存</button>
                            <button onclick="resetPrompt('article')" style="margin-right: 0.5rem; padding: 0.5rem 1rem; background: #f56565; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">🔄 リセット</button>
                        </div>
                        <div id="articlePromptMessage" style="display: none; padding: 0.75rem; border-radius: 6px; font-size: 0.9rem; margin-bottom: 0.5rem;"></div>
                    </div>
                </div>
                
                <div style="margin-bottom: 1rem;">
                    <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;">
                        <label for="articleModelSelect" style="font-weight: 600; color: #4a5568;">記事生成モデル:</label>
                        <select id="articleModelSelect" style="padding: 0.5rem; border-radius: 6px; border: 1px solid #e2e8f0; font-size: 0.9rem;">
                            <option value="gpt-4o-mini">GPT-4o-mini - $0.60/$2.40</option>
                            <option value="gpt-4o">GPT-4o (高品質) - $5.00/$15.00</option>
                            <option value="gpt-4-turbo">GPT-4-turbo (最高品質) - $10.00/$30.00</option>
                            <option value="gpt-3.5-turbo">GPT-3.5-turbo (高速・低コスト) - $0.50/$1.50</option>
                            <option value="gpt-4.1-nano">GPT-4.1-nano (超高速) - $0.10/$0.40</option>
                            <option value="gpt-4.1-mini" selected>GPT-4.1-mini (推奨) - $0.40/$1.60</option>
                            <option value="gpt-4.1">GPT-4.1 (最新) - $2.00/$8.00</option>
                            <option value="gpt-o3">GPT-o3 (推論強化) - $2.00/$8.00</option>
                            <option value="gpt-4o-mini-new">GPT-4o-mini (新) - $1.10/$4.40</option>
                        </select>
                    </div>
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 1rem;">
                        <button id="generateArticleBtn" onclick="generateArticle()" style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease;">
                            📝 解説記事を作成
                        </button>
                        <div style="display: flex; align-items: center; gap: 1rem;">
                            <button id="toggleArticleHistoryBtn" onclick="toggleArticleHistory()" style="background: #f7fafc; color: #4a5568; border: 1px solid #e2e8f0; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem; transition: all 0.3s ease;">
                                📜 履歴表示
                            </button>
                            <span id="articleStatus" style="color: #666;"></span>
                        </div>
                    </div>
                </div>
                
                <!-- 記事履歴パネル -->
                <div id="articleHistoryPanel" style="display: none; margin-bottom: 1rem; padding: 1rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
                        <h4 style="margin: 0; color: #2d3748; font-size: 1rem;">📜 記事履歴</h4>
                        <button onclick="toggleArticleHistory()" style="background: transparent; border: none; color: #718096; cursor: pointer; font-size: 1.2rem; padding: 0.25rem;">×</button>
                    </div>
                    <div id="articleHistoryList" style="max-height: 300px; overflow-y: auto;">
                        <p style="color: #718096; text-align: center; padding: 1rem;">履歴を読み込み中...</p>
                    </div>
                </div>
                
                <!-- 編集ツールバー -->
                <div id="articleEditToolbar" style="display: none; margin-bottom: 1rem; padding: 0.75rem; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; gap: 0.5rem;">
                            <button onclick="toggleArticleEdit()" style="background: #4a5568; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                ✏️ 編集
                            </button>
                            <button onclick="saveArticleEdit()" id="saveArticleBtn" style="display: none; background: #38a169; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                💾 保存
                            </button>
                            <button onclick="cancelArticleEdit()" id="cancelArticleBtn" style="display: none; background: #e53e3e; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                                ❌ キャンセル
                            </button>
                        </div>
                        <div id="editingStatus" style="color: #718096; font-size: 0.85rem;"></div>
                    </div>
                </div>
                
                <div id="articleContent" class="article-content" style="line-height: 1.8;">
                    <p style="color: #888; text-align: center; padding: 2rem;">「解説記事を作成」ボタンを押すと、Zenn/Qiita用の記事が生成されます</p>
                </div>
                
                <!-- 編集エリア（Markdownエディタ） -->
                <div id="articleEditArea" style="display: none;">
                    <textarea id="articleEditor" style="width: 100%; min-height: 500px; padding: 1rem; border: 1px solid #e2e8f0; border-radius: 8px; font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace; font-size: 0.9rem; line-height: 1.6; resize: vertical;"></textarea>
                </div>
            </div>
            
            <div id="transcriptTab" class="tab-content">
                <!-- 文字起こし再生成ボタン -->
                <div id="transcriptRegenerateSection" style="display: none; margin-bottom: 0.5rem; padding: 0.4rem 0.6rem; background: #fef5e7; border: 1px solid #f6ad55; border-radius: 6px;">
                    <div style="display: flex; gap: 0.4rem; flex-wrap: wrap;">
                        <button onclick="regenerateContent('transcript')" id="regenerateTranscriptOnlyBtn" 
                                style="background: #3182ce; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.8rem; transition: all 0.3s ease;" 
                                onmouseover="this.style.background='#2c5282'" 
                                onmouseout="this.style.background='#3182ce'">
                            📝 文字起こしのみ再解析
                        </button>
                        <button onclick="regenerateContent('both')" id="regenerateBothFromTranscriptBtn" 
                                style="background: #f56565; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer; font-weight: 500; font-size: 0.8rem; transition: all 0.3s ease;" 
                                onmouseover="this.style.background='#e53e3e'" 
                                onmouseout="this.style.background='#f56565'">
                            🔄 全て再解析
                        </button>
                    </div>
                </div>
                
                <div id="transcript" class="transcript timestamp-transcript">
                    文字起こし結果がここに表示されます...
                </div>
            </div>

            <div class="chat-panel">
                <div class="chat-header">
                    <h3><span class="section-icon">🤖</span>AIアシスタント</h3>
                    <p style="font-size: 0.85rem; color: #666; margin: 0.5rem 0 0 0;">動画内容への質問、解説記事の修正、その他なんでもお聞きください</p>
                    <div id="suggestedQuestions" class="suggested-questions" style="display: none;">
                        <h4 style="margin: 0 0 0.3rem 0; font-size: 0.8rem; color: #4a5568; font-weight: 600;">💡 おすすめ質問</h4>
                        <div id="questionsList"></div>
                    </div>
                </div>
                <div class="chat-messages-panel">
                    <div id="chatMessages" class="chat-messages">
                        <div class="message ai-message">
                            こんにちは！私はAIアシスタントです。🎥<br>
                            動画の内容についての質問、解説記事の修正指示、要約の深掘りなど、何でもお聞きください。<br>
                            まずはYouTube動画を文字起こししてからご利用ください。
                        </div>
                    </div>
                </div>
                <div class="chat-input-panel">
                    <div class="chat-input-container">
                        <textarea id="chatInput" placeholder="質問を入力してください... (Shift+Enterで送信)" rows="2" style="resize: none;"></textarea>
                        <button onclick="sendMessage()" id="chatBtn">送信</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let isTranscriptReady = false;
        let youtubePlayer = null;
        let currentVideoId = null;
        let userInitiatedPlay = false;
        let currentTimestampedSegments = [];
        let currentTimestampedTranscript = '';
        let currentTranscript = '';
        let currentArticle = ''; // 現在の記事内容
        let currentArticleCostInfo = null; // 記事のコスト情報
        let videoSyncInterval = null;
        let hasProcessedContent = false; // 処理済みコンテンツがあるかのフラグ

        // YouTube Player API ready callback
        function onYouTubeIframeAPIReady() {
            console.log('YouTube IFrame API ready');
        }

        function initializeYouTubePlayer(videoId) {
            currentVideoId = videoId;
            
            if (youtubePlayer) {
                // 既存プレイヤーの場合、キューに追加して一時停止状態で読み込み
                youtubePlayer.unMute(); // 音声をオンにする
                youtubePlayer.cueVideoById(videoId);
            } else {
                youtubePlayer = new YT.Player('youtubePlayer', {
                    height: '100%',
                    width: '100%',
                    videoId: videoId,
                    playerVars: {
                        'playsinline': 1,
                        'modestbranding': 1,
                        'rel': 0,
                        'autoplay': 0,
                        'controls': 1,
                        'enablejsapi': 1,
                        'mute': 0,
                        'start': 0,
                        'origin': window.location.origin
                    },
                    events: {
                        'onReady': function(event) {
                            console.log('YouTube player ready');
                            // 音声をオンにする
                            event.target.unMute();
                            // 動画をキューに追加（再生しない）
                            event.target.cueVideoById(videoId);
                        },
                        'onStateChange': function(event) {
                            console.log('Player state changed:', event.data, 'userInitiatedPlay:', userInitiatedPlay);
                            
                            // 意図しない再生を防ぐ（ユーザー開始でない場合のみ）
                            if (event.data === YT.PlayerState.PLAYING && !userInitiatedPlay) {
                                console.log('Preventing autoplay - pausing video');
                                event.target.pauseVideo();
                            }
                            
                            // ユーザーが開始した再生の場合、フラグを維持
                            if (event.data === YT.PlayerState.PLAYING && userInitiatedPlay) {
                                console.log('User initiated play - allowing playback');
                            }
                            
                            // 動画が停止/一時停止した場合、フラグをリセット
                            if (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED) {
                                userInitiatedPlay = false;
                                console.log('Video paused/ended - reset userInitiatedPlay flag');
                            }
                        }
                    }
                });
            }
            
            document.getElementById('videoPlayerContainer').style.display = 'block';
        }

        function seekToTime(seconds) {
            if (youtubePlayer && youtubePlayer.seekTo) {
                console.log('Seeking to time:', seconds, 'seconds');
                userInitiatedPlay = true;
                // 音声をオンにしてから再生
                youtubePlayer.unMute();
                youtubePlayer.seekTo(seconds, true);
                youtubePlayer.playVideo();
                console.log('Video play initiated by user');
                // フラグは onStateChange でリセットされるので、ここではリセットしない
            }
        }

        let userScrolling = false;
        let lastScrollTime = 0;
        let scrollEventAdded = false;

        // 動画とトランスクリプトの同期機能
        function startVideoSync() {
            if (videoSyncInterval) {
                clearInterval(videoSyncInterval);
            }
            
            // ユーザーのスクロール検出（重複追加を防ぐ）
            if (!scrollEventAdded) {
                const transcriptDiv = document.getElementById('transcript');
                
                // スクロールイベント
                transcriptDiv.addEventListener('scroll', handleUserScroll);
                
                // マウスやタッチの操作検出
                transcriptDiv.addEventListener('mousedown', handleUserInteraction);
                transcriptDiv.addEventListener('touchstart', handleUserInteraction);
                transcriptDiv.addEventListener('wheel', handleUserInteraction);
                
                // テキスト選択検出
                document.addEventListener('selectionchange', handleUserInteraction);
                
                scrollEventAdded = true;
            }
            
            videoSyncInterval = setInterval(() => {
                if (youtubePlayer && youtubePlayer.getCurrentTime && currentTimestampedSegments.length > 0) {
                    const currentTime = youtubePlayer.getCurrentTime();
                    highlightCurrentSegment(currentTime);
                }
            }, 1000);
        }

        function handleUserScroll() {
            userScrolling = true;
            lastScrollTime = Date.now();
            // 5秒後に自動スクロールを再開（時間を延長）
            setTimeout(() => {
                if (Date.now() - lastScrollTime >= 5000) {
                    userScrolling = false;
                }
            }, 5000);
        }

        function handleUserInteraction() {
            userScrolling = true;
            lastScrollTime = Date.now();
            // ユーザーが操作した場合は10秒間自動スクロールを停止
            setTimeout(() => {
                if (Date.now() - lastScrollTime >= 10000) {
                    userScrolling = false;
                }
            }, 10000);
        }

        function stopVideoSync() {
            if (videoSyncInterval) {
                clearInterval(videoSyncInterval);
                videoSyncInterval = null;
            }
            userScrolling = false;
            
            // イベントリスナーをクリーンアップ
            if (scrollEventAdded) {
                const transcriptDiv = document.getElementById('transcript');
                transcriptDiv.removeEventListener('scroll', handleUserScroll);
                transcriptDiv.removeEventListener('mousedown', handleUserInteraction);
                transcriptDiv.removeEventListener('touchstart', handleUserInteraction);
                transcriptDiv.removeEventListener('wheel', handleUserInteraction);
                document.removeEventListener('selectionchange', handleUserInteraction);
                scrollEventAdded = false;
            }
        }

        function highlightCurrentSegment(currentTime) {
            // 現在の時間に最も近いセグメントを見つける
            let currentSegmentIndex = -1;
            for (let i = 0; i < currentTimestampedSegments.length; i++) {
                const segment = currentTimestampedSegments[i];
                if (currentTime >= segment.start && currentTime < segment.start + segment.duration) {
                    currentSegmentIndex = i;
                    break;
                }
            }
            
            // 全てのセグメントからハイライトを削除
            document.querySelectorAll('.timestamp-segment').forEach(el => {
                el.classList.remove('current-segment');
            });
            
            // 現在のセグメントをハイライト
            if (currentSegmentIndex >= 0) {
                const segments = document.querySelectorAll('.timestamp-segment');
                if (segments[currentSegmentIndex]) {
                    segments[currentSegmentIndex].classList.add('current-segment');
                    
                    // 自動スクロールの条件をより厳しく
                    const transcriptDiv = document.getElementById('transcript');
                    const isTranscriptVisible = transcriptDiv.offsetParent !== null;
                    const hasSelection = window.getSelection().toString().length > 0;
                    
                    // ユーザーがスクロールしておらず、テキスト選択もしておらず、要素が見える場合のみ自動スクロール
                    if (!userScrolling && !hasSelection && isTranscriptVisible) {
                        segments[currentSegmentIndex].scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }
                }
            }
        }

        // 解説記事生成機能
        async function generateArticle() {
            try {
                const generateBtn = document.getElementById('generateArticleBtn');
                const articleStatus = document.getElementById('articleStatus');
                const articleContent = document.getElementById('articleContent');
                
                if (!currentTranscript) {
                    articleStatus.textContent = '先に動画を文字起こししてください';
                    articleStatus.style.color = '#e53e3e';
                    return;
                }
                
                generateBtn.disabled = true;
                generateBtn.textContent = '📝 作成中...';
                articleStatus.textContent = '解説記事を生成中です...';
                articleStatus.style.color = '#667eea';
                
                console.log('Frontend state before article generation:');
                console.log('- currentTranscript length:', currentTranscript ? currentTranscript.length : 0);
                console.log('- currentTranscript preview:', currentTranscript ? currentTranscript.substring(0, 200) : 'N/A');
                
                const response = await fetch('/generate-article', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        gptModel: document.getElementById('articleModelSelect').value || 'gpt-4.1-mini'
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    
                    // 記事内容とコスト情報を保存
                    currentArticle = data.article;
                    currentArticleCostInfo = {
                        cost: data.cost,
                        model: data.model,
                        tokens: data.tokens
                    };
                    
                    // 新しいdisplayArticle関数を使用してコスト情報付きで表示
                    displayArticle(data.article, currentArticleCostInfo);
                    
                    // 生成されたマークダウンとHTMLを保存（コピー用）
                    window.generatedArticleMarkdown = data.article;
                    window.generatedArticleHTML = marked.parse(data.article);
                    
                    articleStatus.textContent = '記事が生成されました！';
                    articleStatus.style.color = '#38a169';
                    
                    // セッションコストを更新
                    if (data.costs) {
                        updateCosts(data.costs);
                    }
                } else {
                    const errorData = await response.json();
                    articleContent.innerHTML = `<div style="color: #e53e3e; text-align: center; padding: 2rem;">エラー: ${errorData.error}</div>`;
                    articleStatus.textContent = 'エラーが発生しました';
                    articleStatus.style.color = '#e53e3e';
                }
            } catch (error) {
                console.error('Article generation error:', error);
                document.getElementById('articleContent').innerHTML = '<div style="color: #e53e3e; text-align: center; padding: 2rem;">エラーが発生しました</div>';
                document.getElementById('articleStatus').textContent = 'エラーが発生しました';
                document.getElementById('articleStatus').style.color = '#e53e3e';
            } finally {
                document.getElementById('generateArticleBtn').disabled = false;
                document.getElementById('generateArticleBtn').textContent = '📝 解説記事を作成';
            }
        }

        // 記事をMarkdownでクリップボードにコピー
        function copyArticleToClipboard() {
            if (window.generatedArticleMarkdown) {
                navigator.clipboard.writeText(window.generatedArticleMarkdown).then(() => {
                    // 一時的な成功メッセージ
                    const btn = document.querySelector('button[onclick="copyArticleToClipboard()"]');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ Markdown済み';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                    showMessage('Markdownをクリップボードにコピーしました', 'success');
                }).catch(err => {
                    console.error('コピーに失敗しました:', err);
                    showMessage('Markdownコピーに失敗しました', 'error');
                });
            }
        }

        // 記事をHTMLでクリップボードにコピー
        function copyArticleAsHTML() {
            if (window.generatedArticleHTML) {
                navigator.clipboard.writeText(window.generatedArticleHTML).then(() => {
                    // 一時的な成功メッセージ
                    const btn = document.querySelector('button[onclick="copyArticleAsHTML()"]');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ HTML済み';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                    showMessage('HTMLをクリップボードにコピーしました', 'success');
                }).catch(err => {
                    console.error('コピーに失敗しました:', err);
                    showMessage('HTMLコピーに失敗しました', 'error');
                });
            }
        }

        // 記事をテンプレートとして保存
        // Removed saveArticleTemplate function
        /*
        async function saveArticleTemplate() {
            if (!window.generatedArticleMarkdown) {
                showMessage('保存する記事がありません', 'error');
                return;
            }

            try {
                const response = await fetch('/save-article-template', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        article: window.generatedArticleMarkdown
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    // 一時的な成功メッセージ
                    const btn = document.querySelector('button[onclick="saveArticleTemplate()"]');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ 保存済み';
                    setTimeout(() => {
                        btn.textContent = originalText;
                    }, 2000);
                    
                    // テンプレート情報を更新
                    loadTemplateInfo();
                    
                    console.log('テンプレート保存成功:', data.message);
                    showMessage('記事テンプレートを保存しました！', 'success');
                } else {
                    const errorData = await response.json();
                    showMessage(`保存に失敗しました: ${errorData.error}`, 'error');
                }
            } catch (error) {
                console.error('テンプレート保存エラー:', error);
                showMessage('テンプレート保存に失敗しました', 'error');
            }
        }
        */

        // Removed loadTemplateInfo function
        /*
        async function loadTemplateInfo() {
            try {
                const response = await fetch('/templates-info');
                if (response.ok) {
                    const data = await response.json();
                    const templateInfo = document.getElementById('templateInfo');
                    
                    if (data.templates && data.templates.length > 0) {
                        const latest = data.templates[0];
                        const createdDate = new Date(latest.createdAt).toLocaleDateString('ja-JP');
                        templateInfo.innerHTML = `
                            <div>保存済みテンプレート: <strong>${data.templates.length}件</strong></div>
                            <div>最新テンプレート: ${createdDate} 保存</div>
                            <div>構造: ${latest.structure.hasTitle ? 'タイトル' : ''}${latest.structure.hasIntroduction ? '+導入' : ''}${latest.structure.hasCodeBlocks ? '+コード例' : ''}${latest.structure.hasConclusion ? '+まとめ' : ''}</div>
                            <div style="font-size: 0.75rem; color: #64748b; margin-top: 0.25rem;">次回の記事生成時に自動で参考にします</div>
                        `;
                    } else {
                        templateInfo.textContent = 'まだテンプレートが保存されていません。良い記事ができたら「テンプレート保存」してください。';
                    }
                } else {
                    document.getElementById('templateInfo').textContent = 'テンプレート情報の読み込みに失敗しました';
                }
            } catch (error) {
                console.error('テンプレート情報読み込みエラー:', error);
                document.getElementById('templateInfo').textContent = 'テンプレート情報の読み込みに失敗しました';
            }
        }
        */

        // 履歴から記事を読み込み
        async function loadArticleFromHistory() {
            try {
                // 現在のビデオIDを取得
                if (!currentVideoId) {
                    // currentVideoIdがない場合、現在の記事を表示
                    const response = await fetch('/current-article');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.hasArticle && data.article) {
                            displayArticle(data.article);
                        } else {
                            displayNoArticleMessage();
                        }
                    } else {
                        displayNoArticleMessage();
                    }
                    return;
                }

                // 履歴から記事を取得
                const response = await fetch(`/article/${currentVideoId}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.hasArticle && data.article) {
                        displayArticle(data.article);
                    } else {
                        displayNoArticleMessage();
                    }
                } else {
                    displayNoArticleMessage();
                }
            } catch (error) {
                console.error('記事読み込みエラー:', error);
                displayNoArticleMessage();
            }
        }

        // 記事を表示する関数
        function displayArticle(article, costInfo = null) {
            const articleContent = document.getElementById('articleContent');
            if (articleContent) {
                // articleがオブジェクトの場合、適切な文字列を取得
                let articleText = '';
                if (typeof article === 'object' && article !== null) {
                    articleText = article.content || article.text || String(article);
                } else if (typeof article === 'string') {
                    articleText = article;
                } else {
                    articleText = String(article || '');
                }
                
                let renderedContent = articleText;
                if (typeof marked !== 'undefined' && articleText) {
                    try {
                        renderedContent = marked.parse(articleText);
                    } catch (error) {
                        console.error('Error parsing article markdown:', error);
                        renderedContent = articleText.replace(/\n/g, '<br>');
                    }
                }
                
                if (costInfo) {
                    // コスト情報がある場合（新規生成時）
                    articleContent.innerHTML = `
                        <div style="background: #f8fafc; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                <span style="font-weight: 600; color: #4a5568;">💰 生成コスト: $${costInfo.cost.toFixed(6)} (${costInfo.model})</span>
                                <div style="display: flex; gap: 0.5rem;">
                                    <button onclick="copyArticleToClipboard()" style="background: #38a169; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        📋 Markdownコピー
                                    </button>
                                    <button onclick="copyArticleAsHTML()" style="background: #3182ce; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🌐 HTMLコピー
                                    </button>
                                </div>
                            </div>
                            <div style="font-size: 0.85rem; color: #666;">
                                📊 入力: ${costInfo.tokens.input}トークン, 出力: ${costInfo.tokens.output}トークン
                            </div>
                            <div style="font-size: 0.85rem; color: #2d3748; margin-top: 0.5rem;">
                                💡 記事の修正が必要な場合は、下のAIアシスタントで「記事の○○の部分を修正して」などと指示してください
                            </div>
                        </div>
                        <div class="article-markdown">${renderedContent}</div>
                    `;
                } else {
                    // 履歴から読み込み時はシンプルに表示
                    articleContent.innerHTML = `
                        <div style="background: #e6fffa; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border: 1px solid #38b2ac;">
                            <div style="display: flex; justify-content: space-between; align-items: center; gap: 1rem; margin-bottom: 0.5rem;">
                                <span style="font-weight: 600; color: #2d3748;">📚 履歴から読み込まれた記事</span>
                                <div style="display: flex; gap: 0.5rem;">
                                    <button onclick="copyArticleToClipboard()" style="background: #38a169; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        📋 Markdownコピー
                                    </button>
                                    <button onclick="copyArticleAsHTML()" style="background: #3182ce; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.85rem;">
                                        🌐 HTMLコピー
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="article-markdown">${renderedContent}</div>
                    `;
                }
                articleContent.style.textAlign = 'left';
                
                // タイムスタンプリンクを処理
                processTimestampLinks(articleContent);
                
                // 編集ツールバーを表示
                const editToolbar = document.getElementById('articleEditToolbar');
                if (editToolbar) {
                    editToolbar.style.display = 'block';
                }
            }
        }

        // 記事がない場合のメッセージを表示
        function displayNoArticleMessage() {
            const articleContent = document.getElementById('articleContent');
            if (articleContent) {
                articleContent.innerHTML = '<p style="color: #888; text-align: center; padding: 2rem;">まだ記事が生成されていません。「解説記事を作成」ボタンを押してください。</p>';
            }
        }

        // アコーディオンのトグル機能
        function toggleAccordion(contentId) {
            const content = document.getElementById(contentId);
            const arrow = document.getElementById(contentId + 'Arrow');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.classList.add('expanded');
            } else {
                content.style.display = 'none';
                arrow.classList.remove('expanded');
            }
        }

        // タブ切り替え機能
        function switchTab(tabName) {
            // 全てのタブボタンから active クラスを削除
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // 全てのタブコンテンツを非表示
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 選択されたタブをアクティブに
            // イベントが存在する場合（通常のクリック）
            if (typeof event !== 'undefined' && event && event.target) {
                const clickedButton = event.target.closest('.tab-button');
                if (clickedButton) {
                    clickedButton.classList.add('active');
                }
            } else {
                // プログラム的に呼び出された場合、対応するボタンを見つけてアクティブにする
                const tabButton = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
                if (tabButton) {
                    tabButton.classList.add('active');
                }
            }
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // 解説記事タブが選択された場合、記事を読み込み
            if (tabName === 'article') {
                loadArticleFromHistory();
                
                // 保存された記事があれば復元
                if (currentArticle) {
                    displayArticle(currentArticle, currentArticleCostInfo);
                }
            }
            
            // 文字起こしタブが選択された場合、同期を開始
            if (tabName === 'transcript' && currentTimestampedTranscript) {
                setTimeout(() => {
                    startVideoSync();
                }, 100);
            } else if (tabName === 'summary') {
                stopVideoSync();
            }
        }

        // タイムスタンプ付き文字起こしを表示
        function displayTimestampedTranscript() {
            const transcriptDiv = document.getElementById('transcript');
            if (currentTimestampedTranscript) {
                transcriptDiv.innerHTML = currentTimestampedTranscript;
                // 現在文字起こしタブがアクティブな場合のみ同期開始
                if (document.getElementById('transcriptTab').classList.contains('active')) {
                    startVideoSync();
                }
            }
        }

        function extractVideoId(url) {
            const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/;
            const match = url.match(regex);
            return match ? match[1] : null;
        }

        function updateCosts(costs) {
            // セッション料金も分析に統合するため、分析データを再読み込み
            if (costs) {
                loadCostsAnalysis();
            }
        }

        async function loadHistory() {
            try {
                const response = await fetch('/history');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log('History response:', result);
                
                if (result.success) {
                    displayHistory(result.history);
                } else {
                    console.error('History API returned success: false');
                    const historyList = document.getElementById('historyList');
                    if (historyList) {
                        historyList.innerHTML = '<div style="text-align: center; color: #e53e3e; padding: 1rem;">履歴の読み込みに失敗しました</div>';
                    }
                }
            } catch (error) {
                console.error('Error loading history:', error);
                const historyList = document.getElementById('historyList');
                if (historyList) {
                    historyList.innerHTML = '<div style="text-align: center; color: #e53e3e; padding: 1rem;">履歴の読み込み中にエラーが発生しました</div>';
                }
            }
        }

        // 履歴表示の状態管理
        let currentHistoryView = 'timeline';
        let allHistoryData = [];
        let filteredHistoryData = [];

        function displayHistory(history) {
            allHistoryData = history;
            filteredHistoryData = history;
            
            if (!history || history.length === 0) {
                document.getElementById('historyList').innerHTML = '<p>履歴がありません</p>';
                return;
            }

            // タグサジェスチョンを更新
            updateTagSuggestions(history);
            
            // メインタグサジェスチョンを更新
            updateMainTagSuggestions(history);
            
            // 現在のビューに応じて表示
            displayHistoryByView(currentHistoryView);
        }

        function displayHistoryByView(viewType) {
            const historyList = document.getElementById('historyList');
            
            switch(viewType) {
                case 'timeline':
                    displayTimelineHistory();
                    break;
                case 'channel':
                    displayChannelHistory();
                    break;
                case 'tag':
                    displayTagHistory();
                    break;
            }
        }

        function displayTimelineHistory() {
            const historyList = document.getElementById('historyList');
            
            if (filteredHistoryData.length === 0) {
                historyList.innerHTML = '<p>該当する履歴がありません</p>';
                return;
            }

            const historyHTML = filteredHistoryData.map(item => {
                const date = new Date(item.timestamp).toLocaleString('ja-JP');
                const methodClass = item.method === 'subtitle' ? 'method-subtitle' : 'method-whisper';
                const methodText = item.method === 'subtitle' ? '字幕' : 'Whisper';
                const cost = item.cost > 0 ? `$${item.cost.toFixed(4)}` : '無料';
                const languageText = getLanguageDisplayName(item.language || 'original');
                const channelName = item.metadata?.basic?.channel || 'Unknown';
                const videoUrl = item.url || '';
                const tags = item.tags || [];
                const mainTags = item.mainTags || [];
                
                const tagsHTML = tags.length > 0 ? `
                    <div class="video-tags">
                        ${tags.map(tag => `<span class="tag-item" onclick="filterByTag('${tag}'); event.stopPropagation();">${tag}</span>`).join('')}
                    </div>
                ` : '';
                
                const mainTagsHTML = mainTags.length > 0 ? `
                    <div class="video-tags" style="margin: 0.25rem 0;">
                        ${mainTags.map(tag => `<span style="background: #667eea; color: white; padding: 0.25rem 0.5rem; border-radius: 8px; font-size: 0.75rem; font-weight: 600; margin-right: 0.25rem; cursor: pointer;" onclick="filterByTag('${tag}'); event.stopPropagation();">🏷️ ${tag}</span>`).join('')}
                    </div>
                ` : '';
                
                return `
                    <div class="history-item" onclick="loadFromHistory('${item.id}')">
                        <div class="history-title">${item.title}</div>
                        <div class="history-channel">📺 ${channelName}</div>
                        ${mainTagsHTML}
                        ${tagsHTML}
                        <div class="history-url">
                            <a href="${videoUrl}" target="_blank" onclick="event.stopPropagation();">🔗 YouTubeで開く</a>
                        </div>
                        <div class="history-meta">
                            <span>${date}</span>
                            <span>
                                <span class="method-badge ${methodClass}">${methodText}</span>
                                <span class="language-badge">${languageText}</span>
                                <span style="margin-left: 10px;">${cost}</span>
                            </span>
                        </div>
                    </div>
                `;
            }).join('');
            
            historyList.innerHTML = historyHTML;
        }

        function displayChannelHistory() {
            const historyList = document.getElementById('historyList');
            
            // チャンネル別にグループ化
            const channelGroups = {};
            filteredHistoryData.forEach(item => {
                const channel = item.metadata?.basic?.channel || 'Unknown';
                if (!channelGroups[channel]) {
                    channelGroups[channel] = [];
                }
                channelGroups[channel].push(item);
            });

            if (Object.keys(channelGroups).length === 0) {
                historyList.innerHTML = '<p>該当する履歴がありません</p>';
                return;
            }

            let historyHTML = '';
            Object.entries(channelGroups).forEach(([channel, items]) => {
                historyHTML += `
                    <div class="history-group collapsed">
                        <div class="history-group-header" onclick="toggleHistoryGroup(this)">
                            <span>📺 ${channel} (${items.length}件)</span>
                            <span class="toggle-icon">▼</span>
                        </div>
                        <div class="history-group-items">
                            ${items.map(item => createHistoryItemHTML(item)).join('')}
                        </div>
                    </div>
                `;
            });
            
            historyList.innerHTML = historyHTML;
        }

        function displayTagHistory() {
            const historyList = document.getElementById('historyList');
            
            // タグ別にグループ化
            const tagGroups = {};
            filteredHistoryData.forEach(item => {
                const tags = item.tags || ['未分類'];
                tags.forEach(tag => {
                    if (!tagGroups[tag]) {
                        tagGroups[tag] = [];
                    }
                    tagGroups[tag].push(item);
                });
            });

            if (Object.keys(tagGroups).length === 0) {
                historyList.innerHTML = '<p>該当する履歴がありません</p>';
                return;
            }

            let historyHTML = '';
            Object.entries(tagGroups).forEach(([tag, items]) => {
                // 重複を除去
                const uniqueItems = items.filter((item, index, self) => 
                    index === self.findIndex(t => t.id === item.id)
                );
                
                historyHTML += `
                    <div class="history-group collapsed">
                        <div class="history-group-header" onclick="toggleHistoryGroup(this)">
                            <span>🏷️ ${tag} (${uniqueItems.length}件)</span>
                            <span class="toggle-icon">▼</span>
                        </div>
                        <div class="history-group-items">
                            ${uniqueItems.map(item => createHistoryItemHTML(item)).join('')}
                        </div>
                    </div>
                `;
            });
            
            historyList.innerHTML = historyHTML;
        }

        function createHistoryItemHTML(item) {
            const date = new Date(item.timestamp).toLocaleString('ja-JP');
            const methodClass = item.method === 'subtitle' ? 'method-subtitle' : 'method-whisper';
            const methodText = item.method === 'subtitle' ? '字幕' : 'Whisper';
            const cost = item.cost > 0 ? `$${item.cost.toFixed(4)}` : '無料';
            const languageText = getLanguageDisplayName(item.language || 'original');
            const videoUrl = item.url || '';
            const tags = item.tags || [];
            const mainTags = item.mainTags || [];
            
            const tagsHTML = tags.length > 0 ? `
                <div class="video-tags">
                    ${tags.map(tag => `<span class="tag-item">${tag}</span>`).join('')}
                </div>
            ` : '';
            
            const mainTagsHTML = mainTags.length > 0 ? `
                <div class="video-tags" style="margin: 0.25rem 0;">
                    ${mainTags.map(tag => `<span style="background: #667eea; color: white; padding: 0.25rem 0.5rem; border-radius: 8px; font-size: 0.75rem; font-weight: 600; margin-right: 0.25rem;">🏷️ ${tag}</span>`).join('')}
                </div>
            ` : '';
            
            return `
                <div class="history-item" onclick="loadFromHistory('${item.id}')">
                    <div class="history-title">${item.title}</div>
                    ${mainTagsHTML}
                    ${tagsHTML}
                    <div class="history-url">
                        <a href="${videoUrl}" target="_blank" onclick="event.stopPropagation();">🔗 YouTubeで開く</a>
                    </div>
                    <div class="history-meta">
                        <span>${date}</span>
                        <span>
                            <span class="method-badge ${methodClass}">${methodText}</span>
                            <span class="language-badge">${languageText}</span>
                            <span style="margin-left: 10px;">${cost}</span>
                        </span>
                    </div>
                </div>
            `;
        }

        async function loadFromHistory(videoId) {
            try {
                const response = await fetch('/load-from-history', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ videoId: videoId })
                });

                const result = await response.json();

                if (result.success) {
                    // タイムスタンプ情報を保存
                    currentTimestampedSegments = result.timestampedSegments || [];
                    
                    // YouTubeプレイヤーを初期化（URLから動画IDを取得）
                    if (result.metadata?.basic?.videoId) {
                        initializeYouTubePlayer(result.metadata.basic.videoId);
                        setCurrentVideoId(result.metadata.basic.videoId);
                    }
                    
                    // タイムスタンプ付き文字起こしを取得して表示
                    fetch('/transcript')
                        .then(response => response.json())
                        .then(transcriptData => {
                            if (transcriptData.timestampedTranscript) {
                                currentTimestampedTranscript = transcriptData.timestampedTranscript;
                                displayTimestampedTranscript();
                            } else {
                                // タイムスタンプがない場合は通常の文字起こしを表示
                                const transcriptDiv = document.getElementById('transcript');
                                transcriptDiv.innerHTML = result.transcript.replace(/\n/g, '<br>');
                                transcriptDiv.style.whiteSpace = 'pre-wrap';
                            }
                        });
                    
                    // 動画情報を表示
                    if (result.metadata) {
                        displayVideoInfo(result.metadata, result.method, result.language, result.detectedLanguage);
                    }
                    
                    // 要約を表示
                    if (result.summary) {
                        displaySummary(result.summary);
                    }
                    
                    // 推奨質問を読み込み
                    loadSuggestedQuestions();
                    
                    showMessage(`履歴から読み込みました: ${result.title}`, 'success');
                    isTranscriptReady = true;
                    
                    // コンテンツが読み込まれたフラグを更新
                    hasProcessedContent = true;
                    currentTranscript = result.transcript || '';
                    
                    // ボタンテキストを更新
                    updateUploadButtonText();
                    ensureChatInputVisible();
                } else {
                    showMessage(`エラー: ${result.error}`, 'error');
                }
            } catch (error) {
                console.error('Error:', error);
                showMessage('履歴の読み込みでエラーが発生しました。', 'error');
            }
        }

        // 新機能の関数
        function displayVideoInfo(metadata, method, language, detectedLanguage) {
            if (!metadata) return;
            
            const videoInfo = document.getElementById('videoInfo');
            const basic = metadata.basic;
            
            document.getElementById('videoTitle').textContent = basic.title;
            document.getElementById('videoChannel').textContent = basic.channel;
            document.getElementById('videoDuration').textContent = 
                `${Math.floor(basic.duration/60)}分${basic.duration%60}秒`;
            document.getElementById('videoViews').textContent = 
                basic.viewCount ? basic.viewCount.toLocaleString() + '回' : 'N/A';
            
            let methodText = method === 'subtitle' ? 'YouTube字幕' : 'Whisper API';
            if (detectedLanguage && detectedLanguage !== language) {
                methodText += ` (${detectedLanguage})`;
            }
            document.getElementById('processingMethod').textContent = methodText;
            
            // チャプター情報
            if (metadata.chapters && metadata.chapters.length > 0) {
                const chaptersInfo = document.getElementById('chaptersInfo');
                const chaptersList = document.getElementById('chaptersList');
                
                chaptersList.innerHTML = metadata.chapters.map(chapter => 
                    `<div class="chapter-item">
                        <span class="chapter-timestamp">${chapter.timestamp}</span>
                        ${chapter.title}
                    </div>`
                ).join('');
                
                chaptersInfo.style.display = 'block';
            }
            
            videoInfo.style.display = 'block';
        }

        function displaySummary(summary) {
            if (!summary) return;
            
            const summaryDiv = document.getElementById('summary');
            
            // summaryがオブジェクトの場合、contentプロパティを取得
            let summaryText = '';
            if (typeof summary === 'object' && summary !== null) {
                summaryText = summary.content || summary.text || String(summary);
            } else if (typeof summary === 'string') {
                summaryText = summary;
            } else {
                summaryText = String(summary || '');
            }
            
            let content = summaryText;
            
            // Markdownをレンダリング
            if (typeof marked !== 'undefined' && summaryText) {
                try {
                    content = marked.parse(summaryText);
                } catch (error) {
                    console.error('Error parsing markdown:', error);
                    content = summaryText.replace(/\n/g, '<br>');
                }
            }
            
            // タイムスタンプリンクを追加 [mm:ss-mm:ss] または [mm:ss] の形式を検出
            content = content.replace(/\[(\d{1,2}:\d{2})(?:-(\d{1,2}:\d{2}))?\]/g, function(match, startTime, endTime) {
                const startSeconds = timeToSeconds(startTime);
                return `<span class="timestamp-link" onclick="seekToTime(${startSeconds})">${match}</span>`;
            });
            
            summaryDiv.innerHTML = content;
            summaryDiv.style.display = 'block';
        }
        
        function timeToSeconds(timeStr) {
            const parts = timeStr.split(':').map(p => parseInt(p));
            if (parts.length === 2) {
                // mm:ss形式
                return parts[0] * 60 + parts[1];
            } else if (parts.length === 3) {
                // hh:mm:ss形式
                return parts[0] * 3600 + parts[1] * 60 + parts[2];
            }
            return 0;
        }

        // タイムスタンプリンクを処理する関数
        function processTimestampLinks(element) {
            if (!element) return;
            
            // すべてのテキストノードを取得して処理
            const walker = document.createTreeWalker(
                element,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }
            
            textNodes.forEach(textNode => {
                const text = textNode.textContent;
                // タイムスタンプパターンを検出してリンクに変換
                const processedText = text.replace(/\[(\d{1,2}:\d{2}(?::\d{2})?)\]/g, function(match, timeStr) {
                    const seconds = timeToSeconds(timeStr);
                    return `<span class="timestamp-link" onclick="seekToTime(${seconds})">${match}</span>`;
                });
                
                // テキストが変更された場合のみHTMLを置換
                if (processedText !== text) {
                    const span = document.createElement('span');
                    span.innerHTML = processedText;
                    textNode.parentNode.replaceChild(span, textNode);
                }
            });
        }

        // 記事履歴表示の切り替え
        async function toggleArticleHistory() {
            const historyPanel = document.getElementById('articleHistoryPanel');
            const toggleBtn = document.getElementById('toggleArticleHistoryBtn');
            
            if (historyPanel.style.display === 'none') {
                // 履歴を表示
                if (currentVideoId) {
                    await loadArticleHistory();
                    historyPanel.style.display = 'block';
                    toggleBtn.textContent = '📜 履歴非表示';
                } else {
                    showMessage('❌ 動画を読み込んでください', 'error');
                }
            } else {
                // 履歴を非表示
                historyPanel.style.display = 'none';
                toggleBtn.textContent = '📜 履歴表示';
            }
        }

        // 記事履歴を読み込み
        async function loadArticleHistory() {
            if (!currentVideoId) {
                console.log('No current video ID available');
                return;
            }
            
            try {
                const response = await fetch(`/article-history/${currentVideoId}`);
                const data = await response.json();
                
                if (data.success) {
                    displayArticleHistory(data.history);
                } else {
                    console.error('Error loading article history:', data.error);
                    document.getElementById('articleHistoryList').innerHTML = '<p style="color: #666; text-align: center;">履歴の読み込みに失敗しました</p>';
                }
            } catch (error) {
                console.error('Error loading article history:', error);
                document.getElementById('articleHistoryList').innerHTML = '<p style="color: #666; text-align: center;">履歴の読み込みに失敗しました</p>';
            }
        }

        // 記事履歴を表示
        function displayArticleHistory(history) {
            const historyList = document.getElementById('articleHistoryList');
            
            if (!history || history.length === 0) {
                historyList.innerHTML = '<p style="color: #666; text-align: center;">記事履歴がありません</p>';
                return;
            }
            
            const historyHTML = history.map((item, index) => {
                const date = new Date(item.timestamp).toLocaleString('ja-JP');
                const typeLabel = item.type === 'generated' ? '🤖 生成' : 
                                item.type === 'edited' ? '✏️ 編集' : 
                                item.type === 'merged' ? '🔄 マージ' : '📝 その他';
                
                const preview = item.article.substring(0, 100) + (item.article.length > 100 ? '...' : '');
                
                return `
                    <div style="border: 1px solid #e2e8f0; border-radius: 6px; padding: 0.75rem; margin-bottom: 0.5rem; background: white;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <span style="font-weight: 600; color: #2d3748;">${typeLabel}</span>
                            <span style="font-size: 0.8rem; color: #718096;">${date}</span>
                        </div>
                        <div style="font-size: 0.85rem; color: #4a5568; margin-bottom: 0.5rem;">${preview}</div>
                        <button onclick="restoreArticleFromHistory('${item.id}')" style="background: #3182ce; color: white; border: none; padding: 0.3rem 0.75rem; border-radius: 4px; cursor: pointer; font-size: 0.8rem;">
                            復元
                        </button>
                    </div>
                `;
            }).join('');
            
            historyList.innerHTML = historyHTML;
        }

        // 履歴から記事を復元
        async function restoreArticleFromHistory(historyId) {
            if (!currentVideoId) {
                showMessage('❌ 動画IDが見つかりません', 'error');
                return;
            }
            
            try {
                const response = await fetch(`/article-history/${currentVideoId}`);
                const data = await response.json();
                
                if (data.success) {
                    const historyItem = data.history.find(item => item.id === historyId);
                    if (historyItem) {
                        // 記事を表示
                        displayArticle(historyItem.article);
                        showMessage('✅ 履歴から記事を復元しました', 'success');
                    } else {
                        showMessage('❌ 履歴アイテムが見つかりません', 'error');
                    }
                } else {
                    showMessage('❌ 履歴の読み込みに失敗しました', 'error');
                }
            } catch (error) {
                console.error('Error restoring from history:', error);
                showMessage('❌ 履歴の復元に失敗しました', 'error');
            }
        }

        async function loadSuggestedQuestions() {
            try {
                const response = await fetch('/suggested-questions');
                const result = await response.json();
                
                console.log('Debug: API response:', result);
                
                if (result.success && result.questions.length > 0) {
                    displaySuggestedQuestions(result.questions);
                } else {
                    // テスト用の質問を表示
                    console.log('Debug: No questions from API, showing test questions');
                    const testQuestions = [
                        '動画の内容を詳しく説明してください',
                        '重要なポイントを教えてください',
                        'この動画から学べることは何ですか？',
                        '実践的に活用できる内容はありますか？'
                    ];
                    displaySuggestedQuestions(testQuestions);
                }
            } catch (error) {
                console.error('Error loading suggested questions:', error);
            }
        }

        function displaySuggestedQuestions(questions) {
            const suggestedDiv = document.getElementById('suggestedQuestions');
            const questionsList = document.getElementById('questionsList');
            
            questionsList.innerHTML = questions.map(question => 
                `<div class="question-item" onclick="askSuggestedQuestion('${question.replace(/'/g, "\\'")}')">
                    ${question}
                </div>`
            ).join('');
            
            suggestedDiv.style.display = 'block';
            
            // Ensure chat input remains visible after questions are displayed
            setTimeout(() => {
                ensureChatInputVisible();
            }, 100);
        }

        function askSuggestedQuestion(question) {
            document.getElementById('chatInput').value = question;
            sendMessage();
        }

        function ensureChatInputVisible() {
            // Force chat input panel to be visible
            const chatInputPanel = document.querySelector('.chat-input-panel');
            const chatInputContainer = document.querySelector('.chat-input-container');
            const chatInput = document.getElementById('chatInput');
            const chatBtn = document.getElementById('chatBtn');
            
            if (chatInputPanel) {
                chatInputPanel.style.display = 'flex';
                chatInputPanel.style.visibility = 'visible';
                chatInputPanel.style.position = 'absolute';
                chatInputPanel.style.bottom = '0';
                chatInputPanel.style.left = '0';
                chatInputPanel.style.right = '0';
                chatInputPanel.style.zIndex = '100';
            }
            
            if (chatInputContainer) {
                chatInputContainer.style.display = 'flex';
                chatInputContainer.style.visibility = 'visible';
            }
            
            if (chatInput) {
                chatInput.style.display = 'block';
                chatInput.style.visibility = 'visible';
            }
            
            if (chatBtn) {
                chatBtn.style.display = 'block';
                chatBtn.style.visibility = 'visible';
            }
            
            console.log('Chat input visibility ensured');
        }

        function extractAndDisplayQuestionsFromSummary(summaryContent) {
            try {
                // summaryContentがオブジェクトの場合、適切な文字列を取得
                let summaryText = '';
                if (typeof summaryContent === 'object' && summaryContent !== null) {
                    summaryText = summaryContent.content || summaryContent.text || String(summaryContent);
                } else if (typeof summaryContent === 'string') {
                    summaryText = summaryContent;
                } else {
                    summaryText = String(summaryContent || '');
                }
                
                console.log('Extracting questions from summary:', summaryText ? summaryText.substring(0, 200) + '...' : 'null');
                
                if (!summaryText) {
                    console.log('No summary content provided');
                    return;
                }
                
                // サーバー側と同じロジックで深掘り質問を抽出
                const questionPatterns = [
                    /6\.\s*\*\*💡\s*おすすめ深掘り質問\*\*\s*([\s\S]*?)(?=\n\n|$)/i,
                    /\*\*💡\s*おすすめ深掘り質問\*\*\s*([\s\S]*?)(?=\n\n|$)/i,
                    /💡\s*おすすめ深掘り質問[:\s]*([\s\S]*?)(?=\n\n|$)/i,
                    /おすすめ深掘り質問[:\s]*([\s\S]*?)(?=\n\n|$)/i
                ];
                
                let extractedQuestions = [];
                for (const pattern of questionPatterns) {
                    const questionsMatch = summaryText.match(pattern);
                    if (questionsMatch) {
                        console.log('Found questions match with pattern:', pattern.toString());
                        const questionsText = questionsMatch[1];
                        console.log('Questions text:', questionsText);
                        
                        extractedQuestions = questionsText
                            .split(/\n/)
                            .map(line => line.trim())
                            .filter(line => {
                                // より柔軟な質問の開始パターンを検出
                                return line.startsWith('-') || 
                                       line.startsWith('•') || 
                                       line.match(/^\d+[\.\)]/) ||
                                       (line.includes('？') && line.length > 5);
                            })
                            .map(line => {
                                // 先頭の記号や番号を削除
                                return line.replace(/^[-•\d\.\)\s]+/, '').trim();
                            })
                            .filter(q => q.length > 5 && q.includes('？'))
                            .slice(0, 5); // 最大5個まで
                        
                        console.log('Extracted questions:', extractedQuestions);
                        
                        if (extractedQuestions.length > 0) {
                            displaySuggestedQuestions(extractedQuestions);
                            return;
                        }
                    }
                }
                
                // 深掘り質問が見つからない場合は汎用的な質問を表示
                console.log('No specific questions found, using fallback');
                const fallbackQuestions = [
                    '動画の内容を詳しく説明してください',
                    '重要なポイントを教えてください',
                    'この動画から学べることは何ですか？'
                ];
                displaySuggestedQuestions(fallbackQuestions);
                
            } catch (error) {
                console.error('Error extracting questions from summary:', error);
            }
        }

        function getLanguageDisplayName(language) {
            switch (language) {
                case 'ja': return '日本語';
                case 'en': return 'English';
                case 'original': 
                default: return 'Original';
            }
        }

        // 料金タブ切り替え
        function switchCostsTab(tabName) {
            document.querySelectorAll('.costs-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.costs-tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            event.target.classList.add('active');
            document.getElementById(tabName + 'Costs').classList.add('active');
            
            if (tabName === 'analysis') {
                loadCostsAnalysis();
            } else if (tabName === 'graph') {
                loadCostsGraph();
            }
        }

        // 料金分析データの読み込み
        async function loadCostsAnalysis() {
            try {
                const period = document.getElementById('periodSelect').value;
                const response = await fetch(`/costs-analysis?period=${period}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    displayCostsAnalysis(result);
                } else {
                    throw new Error(result.error || '分析データの取得に失敗しました');
                }
            } catch (error) {
                console.error('Error loading costs analysis:', error);
                const errorMessage = error.message || '分析データの読み込みに失敗しました';
                document.getElementById('costsAnalysisResult').innerHTML = 
                    `<p style="color: red;">エラー: ${errorMessage}</p>`;
            }
        }

        // 料金分析結果の表示
        function displayCostsAnalysis(data) {
            const { summary, period, sessionCosts } = data;
            let html = `
                <div class="costs-analysis-summary">
                    <h4>📊 ${getPeriodDisplayName(period)} 集計</h4>
                    <div class="cost-item">
                        <span>動画処理数:</span>
                        <span>${summary.videoCount} 件</span>
                    </div>
                    <div class="cost-item">
                        <span>Whisper合計:</span>
                        <span>$${summary.totalWhisper.toFixed(4)}</span>
                    </div>
                    <div class="cost-item">
                        <span>GPT合計:</span>
                        <span>$${summary.totalGpt.toFixed(4)}</span>
                    </div>`;
            
            // セッション料金を追加（今日のデータの場合のみ）
            if (period === 'today' && sessionCosts) {
                html += `
                    <div class="cost-item">
                        <span>セッション (Whisper):</span>
                        <span>$${sessionCosts.whisper.toFixed(4)}</span>
                    </div>
                    <div class="cost-item">
                        <span>セッション (GPT):</span>
                        <span>$${sessionCosts.gpt.toFixed(4)}</span>
                    </div>`;
            }
            
            html += `
                    <div class="cost-item total-cost">
                        <span>総合計:</span>
                        <span>$${summary.totalCost.toFixed(4)}</span>
                    </div>
                </div>
                
                <div class="costs-accordion">
                    <div class="accordion-header" onclick="toggleAccordion('methodCosts')">
                        <span>📈 処理方法別</span>
                        <span class="accordion-arrow" id="methodCostsArrow">▼</span>
                    </div>
                    <div class="accordion-content" id="methodCosts" style="display: none;">
                        ${Object.entries(summary.byMethod).map(([method, data]) => `
                            <div class="cost-item">
                                <span>${method === 'subtitle' ? 'YouTube字幕' : 'Whisper API'} (${data.count}件):</span>
                                <span>$${data.cost.toFixed(4)}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="costs-accordion">
                    <div class="accordion-header" onclick="toggleAccordion('modelCosts')">
                        <span>🤖 GPTモデル別</span>
                        <span class="accordion-arrow" id="modelCostsArrow">▼</span>
                    </div>
                    <div class="accordion-content" id="modelCosts" style="display: none;">
                        ${Object.entries(summary.byModel).map(([model, data]) => `
                            <div class="cost-item">
                                <span>${model} (${data.count}件):</span>
                                <span>$${data.cost.toFixed(4)}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            document.getElementById('costsAnalysisResult').innerHTML = html;
        }

        function getPeriodDisplayName(period) {
            switch (period) {
                case 'today': return '本日';
                case 'week': return '過去7日間';
                case 'month': return '過去30日間';
                case 'total': return '全期間';
                default: return period;
            }
        }

        // グラフ描画機能
        async function loadCostsGraph() {
            try {
                const period = document.getElementById('graphPeriodSelect').value;
                const response = await fetch(`/costs-analysis?period=${period}`);
                const result = await response.json();
                
                if (result.success) {
                    drawCostsChart(result);
                }
            } catch (error) {
                console.error('Error loading costs graph:', error);
            }
        }
        
        function drawCostsChart(data) {
            const canvas = document.getElementById('costsChart');
            const ctx = canvas.getContext('2d');
            const { summary } = data;
            
            // キャンバスをクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 日別データを取得
            const byDate = summary.byDate || {};
            const dates = Object.keys(byDate).sort();
            
            if (dates.length === 0) {
                ctx.fillStyle = '#666';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('データがありません', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // グラフの設定
            const padding = 40;
            const graphWidth = canvas.width - padding * 2;
            const graphHeight = canvas.height - padding * 2;
            const startX = padding;
            const startY = padding;
            
            // データの最大値を取得
            const maxCost = Math.max(...dates.map(date => byDate[date].cost), 0.001);
            
            // 軸を描画
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Y軸
            ctx.moveTo(startX, startY);
            ctx.lineTo(startX, startY + graphHeight);
            // X軸
            ctx.moveTo(startX, startY + graphHeight);
            ctx.lineTo(startX + graphWidth, startY + graphHeight);
            ctx.stroke();
            
            // Y軸のラベル（料金）
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = (maxCost / 5) * i;
                const y = startY + graphHeight - (graphHeight / 5) * i;
                ctx.fillText(`$${value.toFixed(3)}`, startX - 5, y + 3);
                
                // グリッド線
                if (i > 0) {
                    ctx.strokeStyle = '#f0f0f0';
                    ctx.beginPath();
                    ctx.moveTo(startX, y);
                    ctx.lineTo(startX + graphWidth, y);
                    ctx.stroke();
                }
            }
            
            // 折れ線グラフを描画
            if (dates.length > 1) {
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                dates.forEach((date, index) => {
                    const x = startX + (graphWidth / (dates.length - 1)) * index;
                    const cost = byDate[date].cost;
                    const y = startY + graphHeight - (cost / maxCost) * graphHeight;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // データポイントを描画
                ctx.fillStyle = '#667eea';
                dates.forEach((date, index) => {
                    const x = startX + (graphWidth / (dates.length - 1)) * index;
                    const cost = byDate[date].cost;
                    const y = startY + graphHeight - (cost / maxCost) * graphHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
            
            // X軸のラベル（日付）
            ctx.fillStyle = '#666';
            ctx.font = '8px Arial';
            ctx.textAlign = 'center';
            const maxLabels = 7; // 最大7個のラベルを表示
            const step = Math.ceil(dates.length / maxLabels);
            
            dates.forEach((date, index) => {
                if (index % step === 0 || index === dates.length - 1) {
                    const x = startX + (graphWidth / (dates.length - 1)) * index;
                    const shortDate = date.slice(5); // MM-DD形式
                    ctx.save();
                    ctx.translate(x, startY + graphHeight + 15);
                    ctx.rotate(-Math.PI / 4); // 45度回転
                    ctx.fillText(shortDate, 0, 0);
                    ctx.restore();
                }
            });
            
            // タイトル
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('日別使用料金', canvas.width / 2, 20);
        }

        
        // パネルリサイズ機能
        let isResizing = false;
        
        function initializeResize() {
            const resizeHandle = document.getElementById('resizeHandle');
            const leftPanel = document.querySelector('.left-panel');
            const mainContent = document.querySelector('.main-content');
            
            if (!resizeHandle) {
                console.error('Resize handle not found');
                return;
            }
            
            resizeHandle.addEventListener('mousedown', function(e) {
                console.log('Mouse down on resize handle');
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
                e.preventDefault();
                e.stopPropagation();
            });
            
            function handleMouseMove(e) {
                if (!isResizing) return;
                
                const containerRect = mainContent.getBoundingClientRect();
                const newWidth = Math.max(250, Math.min(800, e.clientX - containerRect.left - 16)); // 16pxはパディング
                
                leftPanel.style.width = `${newWidth}px`;
                
                console.log('Resizing to:', newWidth);
            }
            
            function handleMouseUp() {
                console.log('Mouse up - stop resizing');
                isResizing = false;
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
            
            // ダブルクリックでリセット
            resizeHandle.addEventListener('dblclick', function() {
                leftPanel.style.width = '350px';
            });
        }

        // 履歴タブ切り替え
        function switchHistoryTab(tabName) {
            currentHistoryView = tabName;
            
            // タブボタンの状態更新
            document.querySelectorAll('.history-tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // 表示更新
            displayHistoryByView(tabName);
        }

        // 履歴フィルタリング
        function filterHistory() {
            const filter = document.getElementById('historyFilter').value;
            const now = new Date();
            
            filteredHistoryData = allHistoryData.filter(item => {
                const itemDate = new Date(item.timestamp);
                
                switch(filter) {
                    case 'today':
                        return itemDate.toDateString() === now.toDateString();
                    case 'week':
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        return itemDate >= weekAgo;
                    case 'month':
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        return itemDate >= monthAgo;
                    default:
                        return true;
                }
            });
            
            displayHistoryByView(currentHistoryView);
        }

        // 履歴検索
        function searchHistory() {
            const searchTerm = document.getElementById('historySearch').value.toLowerCase();
            
            if (!searchTerm) {
                filterHistory(); // フィルターのみ適用
                return;
            }
            
            const baseFilter = document.getElementById('historyFilter').value;
            let baseData = allHistoryData;
            
            // まず日付フィルターを適用
            if (baseFilter !== 'all') {
                const now = new Date();
                baseData = allHistoryData.filter(item => {
                    const itemDate = new Date(item.timestamp);
                    
                    switch(baseFilter) {
                        case 'today':
                            return itemDate.toDateString() === now.toDateString();
                        case 'week':
                            const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                            return itemDate >= weekAgo;
                        case 'month':
                            const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                            return itemDate >= monthAgo;
                        default:
                            return true;
                    }
                });
            }
            
            // テキスト検索を適用
            filteredHistoryData = baseData.filter(item => {
                return item.title.toLowerCase().includes(searchTerm) ||
                       (item.metadata?.basic?.channel || '').toLowerCase().includes(searchTerm) ||
                       (item.tags || []).some(tag => tag.toLowerCase().includes(searchTerm));
            });
            
            displayHistoryByView(currentHistoryView);
        }

        // タグによるフィルタリング
        function filterByTag(tag) {
            document.getElementById('historySearch').value = tag;
            searchHistory();
            
            // タグタブに切り替え
            currentHistoryView = 'tag';
            document.querySelectorAll('.history-tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector('.history-tab-button:nth-child(3)').classList.add('active');
            displayHistoryByView('tag');
        }

        // タグサジェスチョン更新
        function updateTagSuggestions(history) {
            const allTags = new Set();
            history.forEach(item => {
                if (item.tags) {
                    item.tags.forEach(tag => allTags.add(tag));
                }
            });
            
            const tagArray = Array.from(allTags).slice(0, 10); // 最大10個
            
            if (tagArray.length > 0) {
                const suggestionsDiv = document.getElementById('tagSuggestions');
                const suggestionTagsDiv = suggestionsDiv.querySelector('.suggestion-tags');
                
                suggestionTagsDiv.innerHTML = tagArray.map(tag => 
                    `<span class="suggestion-tag" onclick="addTagToInput('${tag}')">${tag}</span>`
                ).join('');
                
                suggestionsDiv.style.display = 'block';
            }
        }

        // タグ入力にタグを追加
        function addTagToInput(tag) {
            // メインタグシステムに統合されたため、この機能は不要
        }

        // メインタグ機能
        let selectedMainTagsArray = [];
        let allMainTags = new Set();
        
        function showMainTagSuggestions(input) {
            const suggestionsDiv = document.getElementById('mainTagSuggestions');
            const suggestionListDiv = suggestionsDiv.querySelector('.suggestion-list');
            
            if (!input.trim()) {
                // 入力が空の場合は全タグを表示
                displayAllMainTags(suggestionListDiv);
                suggestionsDiv.style.display = 'block';
                return;
            }
            
            // 入力に基づいてフィルタリング
            const filteredTags = Array.from(allMainTags).filter(tag => 
                tag.name.toLowerCase().includes(input.toLowerCase()) &&
                !selectedMainTagsArray.includes(tag.name)
            );
            
            if (filteredTags.length > 0) {
                suggestionListDiv.innerHTML = filteredTags.map(tag => `
                    <div class="folder-suggestion-item" onclick="addMainTag('${tag.name}')">
                        <span class="folder-icon">🏷️</span>
                        <span class="folder-name">${tag.name}</span>
                        <span class="folder-count">${tag.count}件</span>
                    </div>
                `).join('');
                suggestionsDiv.style.display = 'block';
            } else {
                suggestionsDiv.style.display = 'none';
            }
        }
        
        function displayAllMainTags(container) {
            const availableTags = Array.from(allMainTags).filter(tag => 
                !selectedMainTagsArray.includes(tag.name)
            );
            
            if (availableTags.length === 0) {
                container.innerHTML = '<div class="folder-suggestion-item" style="color: #666; cursor: default;">タグがありません</div>';
                return;
            }
            
            container.innerHTML = availableTags.map(tag => `
                <div class="folder-suggestion-item" onclick="addMainTag('${tag.name}')">
                    <span class="folder-icon">🏷️</span>
                    <span class="folder-name">${tag.name}</span>
                    <span class="folder-count">${tag.count}件</span>
                </div>
            `).join('');
        }
        
        function addMainTag(tagName) {
            if (!selectedMainTagsArray.includes(tagName)) {
                selectedMainTagsArray.push(tagName);
                updateSelectedTagsDisplay();
                document.getElementById('mainTags').value = '';
                document.getElementById('mainTagSuggestions').style.display = 'none';
            }
        }
        
        function removeMainTag(tagName) {
            selectedMainTagsArray = selectedMainTagsArray.filter(tag => tag !== tagName);
            updateSelectedTagsDisplay();
        }
        
        function updateSelectedTagsDisplay() {
            const container = document.getElementById('selectedMainTags');
            container.innerHTML = selectedMainTagsArray.map(tag => `
                <div class="selected-tag">
                    <span>🏷️ ${tag}</span>
                    <span class="remove-tag" onclick="removeMainTag('${tag}')">×</span>
                </div>
            `).join('');
        }
        
        function getSelectedMainTags() {
            return selectedMainTagsArray;
        }
        
        function updateMainTagSuggestions(history) {
            allMainTags.clear();
            const tagCounts = {};
            
            history.forEach(item => {
                const mainTags = item.mainTags || [];
                mainTags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            });
            
            Object.entries(tagCounts).forEach(([name, count]) => {
                allMainTags.add({ name, count });
            });
        }
        
        // 外部クリックでサジェスチョンを閉じる
        document.addEventListener('click', function(event) {
            const mainTagContainer = document.querySelector('.main-tags-container');
            const suggestionsDiv = document.getElementById('mainTagSuggestions');
            
            if (!mainTagContainer.contains(event.target)) {
                suggestionsDiv.style.display = 'none';
            }
        });

        // アコーディオン機能
        function toggleHistoryGroup(headerElement) {
            const group = headerElement.parentElement;
            const toggleIcon = headerElement.querySelector('.toggle-icon');
            
            if (group.classList.contains('collapsed')) {
                group.classList.remove('collapsed');
                toggleIcon.textContent = '▼';
            } else {
                group.classList.add('collapsed');
                toggleIcon.textContent = '▶';
            }
        }

        // ページ読み込み時に履歴を取得
        window.onload = function() {
            loadHistory();
            loadCostsAnalysis(); // デフォルトで分析を読み込み
            initializeResize(); // リサイズ機能を初期化
            restoreLatestSession(); // 最新セッションを復元
            initializeChatInput(); // チャット入力の初期化
        };

        // チャット入力の初期化
        function initializeChatInput() {
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter') {
                        if (event.shiftKey) {
                            // Shift+Enterで送信
                            event.preventDefault();
                            sendMessage();
                        }
                        // Enterのみの場合は改行（デフォルト動作）
                    }
                });
            }
        }

        // 最新セッションの設定を復元する関数（URLは除く）
        async function restoreLatestSession() {
            try {
                const response = await fetch('/history');
                const historyData = await response.json();
                
                if (historyData.success && historyData.history && historyData.history.length > 0) {
                    const latestEntry = historyData.history[0];
                    
                    // URLは自動設定しない（ユーザーが手動で入力する）
                    // if (latestEntry.url) {
                    //     document.getElementById('youtubeUrl').value = latestEntry.url;
                    // }
                    
                    // 言語設定のみ復元
                    if (latestEntry.language) {
                        document.getElementById('languageSelect').value = latestEntry.language;
                    }
                    
                    // モデル設定のみ復元
                    if (latestEntry.gptModel) {
                        document.getElementById('gptModelSelect').value = latestEntry.gptModel;
                    }
                    
                    // セッション復元は行わない（ユーザーが履歴から手動で選択する）
                    // await displayExistingResult(latestEntry);
                    
                    console.log('🔄 Restored settings from latest session (URL excluded)');
                }
            } catch (error) {
                console.error('Error restoring latest session:', error);
            }
        }

        async function checkForExistingContent() {
            const url = document.getElementById('youtubeUrl').value.trim();
            const language = document.getElementById('languageSelect').value;
            const gptModel = document.getElementById('gptModelSelect').value;
            // Hide all regenerate sections initially
            const summaryRegenerateSection = document.getElementById('summaryRegenerateSection');
            const transcriptRegenerateSection = document.getElementById('transcriptRegenerateSection');
            
            if (!url) {
                if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'none';
                if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'none';
                clearResults();
                return;
            }
            
            try {
                const response = await fetch('/history');
                const historyData = await response.json();
                
                const videoId = extractVideoId(url);
                if (!videoId) {
                    regenerateSection.style.display = 'none';
                    clearResults();
                    return;
                }
                
                // historyが配列かどうかチェック
                const history = Array.isArray(historyData) ? historyData : [];
                const existingEntry = history.find(item => 
                    item.id === videoId && 
                    item.language === language && 
                    item.gptModel === gptModel
                );
                
                if (existingEntry) {
                    // 既存の結果を表示
                    await displayExistingResult(existingEntry);
                    if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'block';
                    if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'block';
                } else {
                    if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'none';
                    if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'none';
                    clearResults();
                }
            } catch (error) {
                console.error('Error checking existing content:', error);
                if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'none';
                if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'none';
                clearResults();
            }
        }
        
        function clearResults() {
            // 結果をクリア（要素の存在チェック付き）
            const transcript = document.getElementById('transcript');
            const summary = document.getElementById('summary');
            const articleContent = document.getElementById('articleContent');
            const videoInfo = document.getElementById('videoInfo');
            const videoPlayer = document.getElementById('videoPlayer');
            
            if (transcript) transcript.innerHTML = '';
            if (summary) summary.innerHTML = '';
            if (articleContent) articleContent.innerHTML = '';
            if (videoInfo) videoInfo.style.display = 'none';
            if (videoPlayer) videoPlayer.style.display = 'none';
            isTranscriptReady = false;
        }
        
        async function displayExistingResult(entry) {
            try {
                // 文字起こし結果を復元
                currentTranscript = entry.transcript || '';
                currentTimestampedSegments = entry.timestampedSegments || [];
                isTranscriptReady = true;
                
                // 履歴から取得した場合は文字起こし開始ボタンを隠し、再生成セクションを表示
                const uploadBtn = document.getElementById('uploadBtn');
                const uploadStatus = document.getElementById('uploadStatus');
                const summaryRegenerateSection = document.getElementById('summaryRegenerateSection');
                const transcriptRegenerateSection = document.getElementById('transcriptRegenerateSection');
                
                if (uploadBtn) uploadBtn.style.display = 'block';
                if (uploadStatus) uploadStatus.innerHTML = '<div style="color: #2d5016; background: #f0f9e8; padding: 0.5rem; border-radius: 6px; font-size: 0.9rem; margin: 0.5rem 0;">📋 履歴から取得済み - 再解析や新しい動画を処理できます</div>';
                if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'block';
                if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'block';
                
                // YouTubeプレイヤーを初期化（エラーハンドリング付き）
                if (entry.id) {
                    try {
                        initializeYouTubePlayer(entry.id);
                    } catch (error) {
                        console.warn('YouTube player initialization failed:', error);
                        // プレイヤー初期化失敗は無視して続行
                    }
                }
                
                // タイムスタンプ付き文字起こしを表示
                if (entry.timestampedTranscript) {
                    currentTimestampedTranscript = entry.timestampedTranscript;
                    displayTimestampedTranscript();
                } else {
                    // 通常の文字起こしを表示
                    const transcriptDiv = document.getElementById('transcript');
                    transcriptDiv.innerHTML = entry.transcript ? entry.transcript.replace(/\n/g, '<br>') : '';
                    transcriptDiv.style.whiteSpace = 'pre-wrap';
                }
                
                // 動画情報を表示
                if (entry.metadata) {
                    displayVideoInfo(entry.metadata, entry.method, entry.language, entry.detectedLanguage);
                }
                
                // 要約を表示
                if (entry.summary) {
                    displaySummary(entry.summary);
                    // 履歴から復元した場合、要約から直接深掘り質問を抽出
                    extractAndDisplayQuestionsFromSummary(entry.summary);
                }
                
                // 解説記事を表示
                if (entry.articleContent) {
                    // articleContentがオブジェクトの場合、適切な文字列を取得
                    let articleText = '';
                    if (typeof entry.articleContent === 'object' && entry.articleContent !== null) {
                        articleText = entry.articleContent.content || entry.articleContent.text || String(entry.articleContent);
                    } else if (typeof entry.articleContent === 'string') {
                        articleText = entry.articleContent;
                    } else {
                        articleText = String(entry.articleContent || '');
                    }
                    
                    // グローバル状態に保存
                    currentArticle = articleText;
                    currentArticleCostInfo = null; // 履歴からの復元時はコスト情報なし
                    
                    // 記事を表示
                    displayArticle(articleText);
                }
                
                // コストを表示
                if (entry.costs) {
                    updateCosts(entry.costs);
                }
                
                // 推奨質問を読み込み
                loadSuggestedQuestions();
                
                showMessage(`過去の結果を表示しました: ${entry.title || 'YouTube動画'} (履歴から取得)`, 'success');
                
            } catch (error) {
                console.error('Error displaying existing result:', error);
                showMessage('過去の結果の表示中にエラーが発生しました', 'error');
            }
        }

        async function regenerateContent(type) {
            const url = document.getElementById('youtubeUrl').value.trim();
            const language = document.getElementById('languageSelect').value;
            const gptModel = document.getElementById('gptModelSelect').value;
            const mainTags = getSelectedMainTags();
            
            if (!url) {
                showMessage('YouTubeのURLを入力してください', 'error');
                return;
            }

            // ボタンの状態を更新 (新しいボタンID)
            const transcriptBtn = document.getElementById('regenerateTranscriptOnlyBtn');
            const summaryBtn = document.getElementById('regenerateSummaryOnlyBtn');
            const bothBtn = document.getElementById('regenerateBothFromTranscriptBtn');
            
            // すべてのボタンを無効化
            [transcriptBtn, summaryBtn, bothBtn].forEach(btn => {
                if (btn) btn.disabled = true;
            });
            
            try {
                let endpoint, bodyData, statusMessage;
                
                switch (type) {
                    case 'transcript':
                        endpoint = '/upload-youtube';
                        bodyData = { url, language, gptModel, mainTags, tags: '', forceRegenerate: true, regenerateType: 'transcript' };
                        statusMessage = '📝 文字起こしを再解析中...';
                        if (transcriptBtn) transcriptBtn.textContent = '再解析中...';
                        break;
                    case 'summary':
                        endpoint = '/regenerate-summary';
                        bodyData = { url, language, gptModel };
                        statusMessage = '📋 要約を再解析中...';
                        if (summaryBtn) summaryBtn.textContent = '再解析中...';
                        break;
                    case 'both':
                        endpoint = '/upload-youtube';
                        bodyData = { url, language, gptModel, mainTags, tags: '', forceRegenerate: true, regenerateType: 'both' };
                        statusMessage = '🔄 全て再解析中...';
                        if (bothBtn) bothBtn.textContent = '再解析中...';
                        break;
                    default:
                        throw new Error('Invalid regenerate type');
                }
                
                showMessage(statusMessage, 'loading');
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(bodyData)
                });

                const result = await response.json();

                if (result.success) {
                    // 結果を表示
                    if (type === 'transcript' || type === 'both') {
                        // タイムスタンプ情報を保存
                        currentTimestampedSegments = result.timestampedSegments || [];
                        
                        // YouTubeプレイヤーを初期化
                        if (result.metadata?.basic?.videoId) {
                            initializeYouTubePlayer(result.metadata.basic.videoId);
                            setCurrentVideoId(result.metadata.basic.videoId);
                        }
                        
                        // 文字起こしを表示
                        fetch('/transcript')
                            .then(response => response.json())
                            .then(transcriptData => {
                                if (transcriptData.timestampedTranscript) {
                                    currentTimestampedTranscript = transcriptData.timestampedTranscript;
                                    displayTimestampedTranscript();
                                } else {
                                    const transcriptDiv = document.getElementById('transcript');
                                    transcriptDiv.innerHTML = result.transcript.replace(/\n/g, '<br>');
                                    transcriptDiv.style.whiteSpace = 'pre-wrap';
                                }
                            });
                        
                        // 動画情報を表示
                        if (result.metadata) {
                            displayVideoInfo(result.metadata, result.method, result.language, result.detectedLanguage);
                        }
                    }
                    
                    if (type === 'summary' || type === 'both') {
                        // 要約を表示
                        if (result.summary) {
                            displaySummary(result.summary);
                            // 新しく生成された要約から直接深掘り質問を抽出
                            extractAndDisplayQuestionsFromSummary(result.summary);
                        } else {
                            // 要約がない場合はサーバーAPIから取得を試行
                            loadSuggestedQuestions();
                        }
                    }
                    
                    isTranscriptReady = true;
                    ensureChatInputVisible();
                    
                    // コストを更新
                    if (result.costs) {
                        updateCosts(result.costs);
                    }
                    
                    // 履歴を更新
                    loadHistory();
                    
                    const successMessage = type === 'transcript' ? '文字起こしの再解析が完了しました！' :
                                          type === 'summary' ? '要約の再解析が完了しました！' :
                                          '全ての再解析が完了しました！';
                    showMessage(successMessage, 'success');
                    
                } else {
                    showMessage(`エラー: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error regenerating content:', error);
                showMessage('再解析中にエラーが発生しました。もう一度お試しください。', 'error');
            } finally {
                // ボタンの状態を元に戻す
                [transcriptBtn, summaryBtn, bothBtn].forEach(btn => {
                    if (btn) btn.disabled = false;
                });
                
                if (transcriptBtn) transcriptBtn.textContent = '📝 文字起こしのみ再解析';
                if (summaryBtn) summaryBtn.textContent = '📋 要約を再解析';
                if (bothBtn) bothBtn.textContent = '🔄 全て再解析';
            }
        }

        // ボタンテキストを動的に更新する関数
        function updateUploadButtonText() {
            const uploadBtn = document.getElementById('uploadBtn');
            if (!uploadBtn) return;
            
            if (hasProcessedContent && currentTranscript && currentTranscript.trim() !== '') {
                uploadBtn.textContent = '🔄 再解析';
                uploadBtn.title = '文字起こしと要約を再実行します';
            } else {
                uploadBtn.textContent = '解析開始';
                uploadBtn.title = '動画の文字起こしと要約を開始します';
            }
        }

        // URLが変更された時にボタンテキストをチェックする関数
        function checkContentForCurrentUrl() {
            const url = document.getElementById('youtubeUrl').value.trim();
            if (!url) {
                hasProcessedContent = false;
                updateUploadButtonText();
                return;
            }
            
            // 現在のURLで処理済みコンテンツがあるかチェック
            if (currentTranscript && currentTranscript.trim() !== '') {
                hasProcessedContent = true;
            } else {
                hasProcessedContent = false;
            }
            updateUploadButtonText();
        }

        async function uploadYouTube(forceRegenerate = false) {
            console.log('uploadYouTube called with forceRegenerate:', forceRegenerate);
            
            const url = document.getElementById('youtubeUrl').value.trim();
            const language = document.getElementById('languageSelect').value;
            const gptModel = document.getElementById('gptModelSelect').value;
            const uploadBtn = document.getElementById('uploadBtn');
            const uploadStatus = document.getElementById('uploadStatus');
            
            console.log('URL:', url);
            console.log('Language:', language);
            console.log('GPT Model:', gptModel);
            
            if (!url) {
                showMessage('YouTubeのURLを入力してください', 'error');
                return;
            }

            // コンテンツがある場合は自動的に再解析モードにする
            if (!forceRegenerate && hasProcessedContent && currentTranscript && currentTranscript.trim() !== '') {
                forceRegenerate = true;
                console.log('Auto-setting forceRegenerate to true due to existing content');
            }

            uploadBtn.disabled = true;
            
            let mainTags = [];
            let tags = '';
            
            try {
                mainTags = getSelectedMainTags();
            } catch (e) {
                console.warn('Failed to get main tags:', e);
                mainTags = [];
            }
            
            if (forceRegenerate) {
                showMessage('🔄 再生成処理を開始しました。文字起こしと要約を新しく生成中...', 'loading');
            } else {
                uploadBtn.textContent = '処理中...';
                showMessage('YouTube動画を処理中です。しばらくお待ちください...', 'loading');
            }

            try {
                console.log('Sending request to /upload-youtube with:', { url, language, gptModel, mainTags, tags, forceRegenerate });
                
                const response = await fetch('/upload-youtube', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url, language: language, gptModel: gptModel, mainTags: mainTags, tags: tags, forceRegenerate: forceRegenerate })
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                console.log('Response body:', result);

                if (result.success) {
                    // 文字起こし結果を保存
                    currentTranscript = result.transcript || '';
                    // タイムスタンプ情報を保存
                    currentTimestampedSegments = result.timestampedSegments || [];
                    
                    // YouTubeプレイヤーを初期化
                    const videoId = extractVideoId(url);
                    if (videoId) {
                        initializeYouTubePlayer(videoId);
                    }
                    
                    // タイムスタンプ付き文字起こしを取得して表示
                    fetch('/transcript')
                        .then(response => response.json())
                        .then(transcriptData => {
                            if (transcriptData.timestampedTranscript) {
                                currentTimestampedTranscript = transcriptData.timestampedTranscript;
                                displayTimestampedTranscript();
                            } else {
                                // タイムスタンプがない場合は通常の文字起こしを表示
                                const transcriptDiv = document.getElementById('transcript');
                                transcriptDiv.innerHTML = result.transcript.replace(/\n/g, '<br>');
                                transcriptDiv.style.whiteSpace = 'pre-wrap';
                            }
                        });
                    
                    // 動画情報を表示
                    if (result.metadata) {
                        displayVideoInfo(result.metadata, result.method, result.language, result.detectedLanguage);
                    }
                    
                    // 要約を表示
                    if (result.summary) {
                        displaySummary(result.summary);
                    }
                    
                    let message = forceRegenerate ? `再生成が完了しました！動画: ${result.title}` : `文字起こしが完了しました！動画: ${result.title}`;
                    if (result.fromHistory) {
                        message += ' (履歴から取得)';
                    } else {
                        const methodText = result.method === 'subtitle' ? 'YouTube字幕' : 'Whisper API';
                        message += ` (${methodText}使用)`;
                        if (forceRegenerate) {
                            message += ' - 新しく生成';
                        }
                    }
                    
                    showMessage(message, 'success');
                    isTranscriptReady = true;
                    ensureChatInputVisible();
                    
                    // コンテンツ処理完了フラグを更新
                    hasProcessedContent = true;
                    
                    // Save URL to history (newest first)
                    saveUrlToHistory(url);
                    
                    // コストを更新
                    if (result.costs) {
                        updateCosts(result.costs);
                    }
                    
                    // 要約から直接深掘り質問を抽出
                    if (result.summary) {
                        extractAndDisplayQuestionsFromSummary(result.summary);
                    } else {
                        // 要約がない場合はサーバーAPIから取得を試行
                        loadSuggestedQuestions();
                    }
                    
                    // 履歴を更新
                    loadHistory();
                    
                    // 再生成セクションを表示（処理完了後は常に再生成可能）
                    const summaryRegenerateSection = document.getElementById('summaryRegenerateSection');
                    const transcriptRegenerateSection = document.getElementById('transcriptRegenerateSection');
                    if (summaryRegenerateSection) summaryRegenerateSection.style.display = 'block';
                    if (transcriptRegenerateSection) transcriptRegenerateSection.style.display = 'block';
                } else {
                    console.error('Upload failed:', result);
                    const errorMessage = result.message || result.error || 'Unknown error';
                    showMessage(`エラー: ${errorMessage}`, 'error');
                }
            } catch (error) {
                console.error('Error:', error);
                showMessage(`エラーが発生しました: ${error.message}`, 'error');
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.style.display = 'block';
                
                // ボタンテキストを動的に更新
                updateUploadButtonText();
                
                // 再生成セクションは各タブに個別に配置されているので特に処理不要
            }
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            const gptModel = document.getElementById('gptModelSelect').value;
            const chatBtn = document.getElementById('chatBtn');
            const chatMessages = document.getElementById('chatMessages');

            if (!message) return;

            if (!isTranscriptReady) {
                showMessage('まず最初にYouTube動画を文字起こししてください。', 'info');
                return;
            }

            input.value = '';
            chatBtn.disabled = true;
            chatBtn.textContent = '送信中...';

            addMessage(message, 'user');

            try {
                const response = await fetch('/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ message: message, gptModel: gptModel })
                });

                const result = await response.json();

                if (result.success) {
                    addMessage(result.response, 'ai');
                    
                    // コストを更新
                    if (result.costs) {
                        updateCosts(result.costs);
                    }
                } else {
                    addMessage(`エラー: ${result.error}`, 'ai');
                }
            } catch (error) {
                console.error('Error:', error);
                addMessage('エラーが発生しました。もう一度お試しください。', 'ai');
            } finally {
                chatBtn.disabled = false;
                chatBtn.textContent = '送信';
            }
        }

        function addMessage(text, type) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}-message`;
            
            if (type === 'ai') {
                // AIメッセージの場合、Markdownをレンダリングしてタイムスタンプリンクを処理
                let processedText = text;
                
                // Markdownをレンダリング
                if (typeof marked !== 'undefined') {
                    processedText = marked.parse(text);
                } else {
                    // markedが利用できない場合は基本的な変換
                    processedText = text
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // **太字**
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')               // *斜体*
                        .replace(/`(.*?)`/g, '<code>$1</code>')             // `コード`
                        .replace(/\n/g, '<br>');                            // 改行
                }
                
                // タイムスタンプリンクを処理（様々な形式に対応）
                processedText = processedText
                    .replace(/\[(\d{1,2}:\d{2}(?::\d{2})?)\]/g, function(match, timeStr) {
                        const seconds = timeToSeconds(timeStr);
                        return `<span class="timestamp-link" onclick="seekToTime(${seconds})">${match}</span>`;
                    })
                    .replace(/(\d{1,2}:\d{2}(?::\d{2})?)/g, function(match, timeStr) {
                        // []で囲まれていない時間も検出してリンクにする
                        if (!match.includes('span')) { // 既にリンクになっていない場合のみ
                            const seconds = timeToSeconds(timeStr);
                            return `<span class="timestamp-link" onclick="seekToTime(${seconds})">${match}</span>`;
                        }
                        return match;
                    });
                
                messageDiv.innerHTML = processedText;
                
                // 記事に反映ボタンは削除
            } else {
                messageDiv.textContent = text;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // メッセージ表示関数
        function showMessage(message, type = 'info') {
            const uploadStatus = document.getElementById('uploadStatus');
            if (uploadStatus) {
                let className = '';
                let icon = '';
                switch(type) {
                    case 'success':
                        className = 'success-message';
                        icon = '✅';
                        break;
                    case 'error':
                        className = 'error-message';
                        icon = '❌';
                        break;
                    case 'loading':
                        className = 'loading-message';
                        icon = '⏳';
                        break;
                    case 'warning':
                        className = 'warning-message';
                        icon = '⚠️';
                        break;
                    default:
                        className = 'info-message';
                        icon = 'ℹ️';
                }
                
                uploadStatus.innerHTML = `
                    <div class="${className}" style="padding: 0.75rem; border-radius: 6px; margin: 0.5rem 0; background: ${
                        type === 'success' ? '#f0fdf4' : 
                        type === 'error' ? '#fef2f2' : 
                        type === 'warning' ? '#fffbeb' :
                        type === 'loading' ? '#eff6ff' : '#f8fafc'
                    }; color: ${
                        type === 'success' ? '#166534' : 
                        type === 'error' ? '#991b1b' : 
                        type === 'warning' ? '#92400e' :
                        type === 'loading' ? '#1e40af' : '#374151'
                    }; border: 1px solid ${
                        type === 'success' ? '#bbf7d0' : 
                        type === 'error' ? '#fecaca' : 
                        type === 'warning' ? '#fde68a' :
                        type === 'loading' ? '#bfdbfe' : '#e5e7eb'
                    };">
                        ${icon} ${message}
                    </div>
                `;
                
                // エラーまたは成功メッセージは5秒後に自動的に消える
                if (type === 'success' || type === 'error' || type === 'warning') {
                    setTimeout(() => {
                        if (uploadStatus.innerHTML.includes(message)) {
                            uploadStatus.innerHTML = '';
                        }
                    }, 5000);
                }
            }
        }

        // 記事編集機能
        let isArticleEditing = false;
        let originalArticleContent = '';

        function toggleArticleEdit() {
            const articleContent = document.getElementById('articleContent');
            const articleEditor = document.getElementById('articleEditor');
            const articleEditArea = document.getElementById('articleEditArea');
            const saveBtn = document.getElementById('saveArticleBtn');
            const cancelBtn = document.getElementById('cancelArticleBtn');
            const editingStatus = document.getElementById('editingStatus');
            
            if (!isArticleEditing) {
                // 編集モードに入る
                isArticleEditing = true;
                
                // 現在の記事内容を取得（HTMLからMarkdownへ）
                originalArticleContent = getMarkdownFromArticle();
                articleEditor.value = originalArticleContent;
                
                // UIを編集モードに切り替え
                articleContent.style.display = 'none';
                articleEditArea.style.display = 'block';
                saveBtn.style.display = 'inline-block';
                cancelBtn.style.display = 'inline-block';
                editingStatus.textContent = '編集中...';
                
                // エディタにフォーカス
                articleEditor.focus();
            } else {
                // 編集モードを終了
                cancelArticleEdit();
            }
        }

        function saveArticleEdit() {
            const articleContent = document.getElementById('articleContent');
            const articleEditor = document.getElementById('articleEditor');
            const articleEditArea = document.getElementById('articleEditArea');
            const saveBtn = document.getElementById('saveArticleBtn');
            const cancelBtn = document.getElementById('cancelArticleBtn');
            const editingStatus = document.getElementById('editingStatus');
            
            const newContent = articleEditor.value;
            
            // 記事部分のみを更新（既存のコスト情報などは保持）
            const articleMarkdown = articleContent.querySelector('.article-markdown');
            if (articleMarkdown) {
                // .article-markdownの部分のみを更新
                if (typeof marked !== 'undefined') {
                    articleMarkdown.innerHTML = marked.parse(newContent);
                } else {
                    articleMarkdown.innerHTML = newContent.replace(/\n/g, '<br>');
                }
                
                // タイムスタンプリンクを処理
                processTimestampLinks(articleMarkdown);
            } else {
                // .article-markdownが見つからない場合は全体を更新
                if (typeof marked !== 'undefined') {
                    articleContent.innerHTML = marked.parse(newContent);
                } else {
                    articleContent.innerHTML = newContent.replace(/\n/g, '<br>');
                }
                
                // タイムスタンプリンクを処理
                processTimestampLinks(articleContent);
            }
            
            // 生成されたMarkdownを保存
            window.generatedArticleMarkdown = newContent;
            
            // 現在の記事として保存
            if (currentVideoId) {
                // サーバーに保存
                saveArticleToServer(newContent);
            }
            
            // UIを通常モードに戻す
            isArticleEditing = false;
            articleContent.style.display = 'block';
            articleEditArea.style.display = 'none';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            editingStatus.textContent = '';
            
            showMessage('✅ 記事を保存しました', 'success');
        }

        function cancelArticleEdit() {
            const articleContent = document.getElementById('articleContent');
            const articleEditArea = document.getElementById('articleEditArea');
            const saveBtn = document.getElementById('saveArticleBtn');
            const cancelBtn = document.getElementById('cancelArticleBtn');
            const editingStatus = document.getElementById('editingStatus');
            
            // UIを通常モードに戻す
            isArticleEditing = false;
            articleContent.style.display = 'block';
            articleEditArea.style.display = 'none';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
            editingStatus.textContent = '';
        }

        function getMarkdownFromArticle() {
            const articleDiv = document.getElementById('articleContent');
            if (!articleDiv) return '';
            
            // 記事のMarkdown部分のみを抽出（.article-markdownクラスの要素）
            const articleMarkdown = articleDiv.querySelector('.article-markdown');
            if (!articleMarkdown) {
                // .article-markdownが見つからない場合は、window.generatedArticleMarkdownから取得
                return window.generatedArticleMarkdown || '';
            }
            
            // HTMLをMarkdownに変換する簡易実装
            let markdown = '';
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = articleMarkdown.innerHTML;
            
            // 各要素を処理
            const walker = document.createTreeWalker(
                tempDiv,
                NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
                null,
                false
            );
            
            let node;
            let lastNodeName = '';
            while (node = walker.nextNode()) {
                if (node.nodeType === Node.TEXT_NODE) {
                    markdown += node.textContent;
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    const nodeName = node.nodeName.toLowerCase();
                    
                    switch (nodeName) {
                        case 'h1':
                            markdown += '\n# ' + node.textContent + '\n\n';
                            walker.nextSibling();
                            break;
                        case 'h2':
                            markdown += '\n## ' + node.textContent + '\n\n';
                            walker.nextSibling();
                            break;
                        case 'h3':
                            markdown += '\n### ' + node.textContent + '\n\n';
                            walker.nextSibling();
                            break;
                        case 'p':
                            markdown += node.textContent + '\n\n';
                            walker.nextSibling();
                            break;
                        case 'br':
                            markdown += '\n';
                            break;
                        case 'strong':
                        case 'b':
                            markdown += '**' + node.textContent + '**';
                            walker.nextSibling();
                            break;
                        case 'em':
                        case 'i':
                            markdown += '*' + node.textContent + '*';
                            walker.nextSibling();
                            break;
                        case 'code':
                            if (node.parentNode.nodeName.toLowerCase() === 'pre') {
                                markdown += '```\n' + node.textContent + '\n```\n\n';
                                walker.nextSibling();
                                walker.nextSibling();
                            } else {
                                markdown += '`' + node.textContent + '`';
                                walker.nextSibling();
                            }
                            break;
                        case 'ul':
                        case 'ol':
                            const listItems = node.querySelectorAll('li');
                            listItems.forEach((li, index) => {
                                if (nodeName === 'ul') {
                                    markdown += '- ' + li.textContent + '\n';
                                } else {
                                    markdown += (index + 1) + '. ' + li.textContent + '\n';
                                }
                            });
                            markdown += '\n';
                            walker.nextSibling();
                            break;
                    }
                }
            }
            
            return markdown.trim();
        }

        async function saveArticleToServer(articleContent) {
            if (!currentVideoId) return;
            
            try {
                const response = await fetch('/save-article', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        videoId: currentVideoId,
                        article: articleContent
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    console.log('✅ Article saved to server');
                }
            } catch (error) {
                console.error('Failed to save article:', error);
            }
        }
        
        // プロンプト設定関数
        function togglePromptSettings(type) {
            const content = document.getElementById(type + 'PromptSettings');
            const arrow = document.getElementById(type + 'PromptArrow');
            
            if (content.style.display === 'none' || content.style.display === '') {
                content.style.display = 'block';
                arrow.textContent = '▲';
                // 初回表示時にプロンプトを読み込む
                loadPromptForTextarea(type);
            } else {
                content.style.display = 'none';
                arrow.textContent = '▼';
            }
        }
        
        // 旧UIのテキストエリアにプロンプトを読み込む
        async function loadPromptForTextarea(type) {
            try {
                const response = await fetch('/prompts');
                const prompts = await response.json();
                const textarea = document.getElementById(type + 'PromptText');
                
                if (textarea) {
                    let currentPrompt = prompts[type]?.template || '';
                    // \nを実際の改行に変換して表示
                    currentPrompt = currentPrompt.replace(/\\n/g, '\n');
                    textarea.value = currentPrompt;
                }
            } catch (error) {
                console.error('Error loading prompt:', error);
            }
        }
        
        // 旧UIの保存関数
        async function savePrompt(type) {
            const textarea = document.getElementById(type + 'PromptText');
            if (!textarea) return;
            
            let template = textarea.value;
            // 改行はそのまま保存（JSON.stringifyが自動的にエスケープする）
            // template = template.replace(/\n/g, '\\n'); // この行を削除
            
            try {
                const response = await fetch('/prompts/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        type: type,
                        template: template
                    })
                });
                
                const result = await response.json();
                const messageDiv = document.getElementById(type + 'PromptMessage');
                
                if (result.success) {
                    if (messageDiv) {
                        messageDiv.style.display = 'block';
                        messageDiv.style.background = '#d4edda';
                        messageDiv.style.color = '#155724';
                        messageDiv.textContent = '✅ プロンプトを保存しました';
                        setTimeout(() => {
                            messageDiv.style.display = 'none';
                        }, 3000);
                    }
                } else {
                    if (messageDiv) {
                        messageDiv.style.display = 'block';
                        messageDiv.style.background = '#f8d7da';
                        messageDiv.style.color = '#721c24';
                        messageDiv.textContent = '❌ 保存に失敗しました';
                    }
                }
            } catch (error) {
                console.error('Error saving prompt:', error);
                const messageDiv = document.getElementById(type + 'PromptMessage');
                if (messageDiv) {
                    messageDiv.style.display = 'block';
                    messageDiv.style.background = '#f8d7da';
                    messageDiv.style.color = '#721c24';
                    messageDiv.textContent = '❌ 保存に失敗しました';
                }
            }
        }
        
        // リセット関数
        async function resetPrompt(type) {
            if (!confirm('プロンプトをデフォルトに戻しますか？')) return;
            
            try {
                // デフォルトプロンプトを空文字として保存（サーバー側でデフォルトが適用される）
                const response = await fetch('/prompts/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        type: type,
                        template: ''
                    })
                });
                
                if (response.ok) {
                    // プロンプトを再読み込み
                    loadPromptForTextarea(type);
                    
                    const messageDiv = document.getElementById(type + 'PromptMessage');
                    if (messageDiv) {
                        messageDiv.style.display = 'block';
                        messageDiv.style.background = '#d4edda';
                        messageDiv.style.color = '#155724';
                        messageDiv.textContent = '✅ デフォルトに戻しました';
                        setTimeout(() => {
                            messageDiv.style.display = 'none';
                        }, 3000);
                    }
                }
            } catch (error) {
                console.error('Error resetting prompt:', error);
            }
        }
        
        async function loadPromptSettings(type) {
            try {
                const response = await fetch('/prompts');
                const prompts = await response.json();
                
                const container = document.getElementById(type + 'PromptSettings');
                let currentPrompt = prompts[type]?.template || '';
                
                // \nを実際の改行に変換して表示
                currentPrompt = currentPrompt.replace(/\\n/g, '\n');
                
                container.innerHTML = `
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">プロンプトテンプレート:</label>
                        <textarea id="${type}PromptTemplate" style="width: 100%; height: 200px; padding: 0.75rem; border: 1px solid #e2e8f0; border-radius: 6px; font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9rem;" placeholder="プロンプトテンプレートを入力...">${currentPrompt.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                    </div>
                    <div style="text-align: right;">
                        <button onclick="savePromptSettings('${type}')" style="background: #4f46e5; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer;">保存</button>
                        <button onclick="resetPromptSettings('${type}')" style="background: #6b7280; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; margin-left: 0.5rem;">リセット</button>
                    </div>
                `;
            } catch (error) {
                console.error('Error loading prompt settings:', error);
            }
        }
        
        async function savePromptSettings(type) {
            let template = document.getElementById(type + 'PromptTemplate').value;
            
            // 改行はそのまま保存（JSON.stringifyが自動的にエスケープする）
            // template = template.replace(/\n/g, '\\n'); // この行を削除
            
            try {
                const response = await fetch('/prompts/save', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        type: type,
                        template: template
                    })
                });
                
                const result = await response.json();
                if (result.success) {
                    showMessage('✅ プロンプト設定を保存しました', 'success');
                } else {
                    showMessage('❌ プロンプト設定の保存に失敗しました', 'error');
                }
            } catch (error) {
                console.error('Error saving prompt settings:', error);
                showMessage('❌ プロンプト設定の保存に失敗しました', 'error');
            }
        }
        
        function resetPromptSettings(type) {
            document.getElementById(type + 'PromptTemplate').value = '';
            showMessage('プロンプトをリセットしました', 'info');
        }
        
        // 分析タブの料金データ読み込み
        async function loadCostsAnalysis() {
            const periodSelect = document.getElementById('periodSelect');
            const period = periodSelect ? periodSelect.value : 'today';
            await loadCostData(period, 'analysis');
        }
        
        // グラフタブの料金データ読み込み
        async function loadCostsGraph() {
            const graphPeriodSelect = document.getElementById('graphPeriodSelect');
            const period = graphPeriodSelect ? graphPeriodSelect.value : 'today';
            await loadCostData(period, 'graph');
        }
        
        async function loadCostData(period = 'today', tabType = 'analysis') {
            try {
                // セッションデータの場合は /session-costs エンドポイントを使用
                if (period === 'session') {
                    const sessionResponse = await fetch('/session-costs');
                    if (!sessionResponse.ok) {
                        throw new Error(`HTTP ${sessionResponse.status}: ${sessionResponse.statusText}`);
                    }
                    const sessionCosts = await sessionResponse.json();
                    displaySessionCosts(sessionCosts, tabType);
                    return;
                }
                
                // 履歴データが必要な場合のみ /costs エンドポイントを呼び出し
                const response = await fetch('/costs');
                if (!response.ok) {
                    throw new Error(`Costs API error! status: ${response.status}`);
                }
                
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('Response is not JSON');
                }
                
                const costs = await response.json();
                
                let filteredCosts = costs;
                const now = new Date();
                
                switch (period) {
                    case 'today':
                        const today = now.toISOString().split('T')[0];
                        filteredCosts = costs.filter(cost => cost.date === today);
                        break;
                    case 'week':
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        filteredCosts = costs.filter(cost => new Date(cost.timestamp) >= weekAgo);
                        break;
                    case 'month':
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        filteredCosts = costs.filter(cost => new Date(cost.timestamp) >= monthAgo);
                        break;
                }
                
                if (tabType === 'graph') {
                    console.log(`Displaying graph for ${period} with ${filteredCosts.length} records`);
                    
                    // デバッグ: フィルタリング期間を表示
                    if (period === 'week') {
                        const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                        console.log(`Week period: from ${weekAgo.toISOString()} to ${now.toISOString()}`);
                    } else if (period === 'month') {
                        const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                        console.log(`Month period: from ${monthAgo.toISOString()} to ${now.toISOString()}`);
                    }
                    
                    // 日付ごとのコストを確認
                    const dateGroups = {};
                    filteredCosts.forEach(cost => {
                        const date = cost.date || cost.timestamp.split('T')[0];
                        if (!dateGroups[date]) {
                            dateGroups[date] = [];
                        }
                        dateGroups[date].push(cost);
                    });
                    console.log(`${period} - Dates with data:`, Object.keys(dateGroups).sort());
                    
                    // 特定の日付のデータを詳しく表示（デバッグ用）
                    const targetDate = '2025-06-18';
                    if (dateGroups[targetDate]) {
                        console.log(`${period} - ${targetDate} entries:`, dateGroups[targetDate].length);
                        const total = dateGroups[targetDate].reduce((sum, cost) => sum + cost.totalCost, 0);
                        console.log(`${period} - ${targetDate} total cost: $${total.toFixed(4)}`);
                    }
                    
                    displayPeriodGraph(filteredCosts, period);
                } else {
                    displayPeriodCosts(filteredCosts, period, tabType);
                }
                
            } catch (error) {
                console.error('Error loading cost data:', error);
                
                // エラー時の表示
                const container = tabType === 'analysis' ? 
                    document.getElementById('costsAnalysisResult') : 
                    document.getElementById('costsGraphResult');
                
                if (container) {
                    const isSessionPeriod = period === 'session';
                    const errorMessage = error.message.includes('Session costs') 
                        ? 'セッションデータの取得に失敗しました。サーバーが起動しているか確認してください。'
                        : error.message.includes('Costs API') 
                        ? '履歴データの取得に失敗しました。サーバーが正常に動作しているか確認してください。'
                        : 'データの読み込みに失敗しました。';
                    
                    container.innerHTML = `
                        <div style="padding: 1rem; background: #fef2f2; border: 1px solid #fecaca; border-radius: 8px; color: #dc2626;">
                            <h4 style="margin: 0 0 0.5rem 0;">❌ ${errorMessage}</h4>
                            <div style="margin: 0.5rem 0; font-size: 0.9rem;">
                                <p style="margin: 0;">考えられる原因:</p>
                                <ul style="margin: 0.5rem 0; padding-left: 1.2rem;">
                                    <li>サーバーが起動していない</li>
                                    <li>ポート番号が異なる</li>
                                    <li>ネットワーク接続の問題</li>
                                </ul>
                            </div>
                            <button onclick="loadCostData('${period}', '${tabType}')" 
                                    style="background: #dc2626; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; font-size: 0.9rem;">
                                再試行
                            </button>
                            <details style="margin-top: 0.5rem;">
                                <summary style="cursor: pointer; font-size: 0.8rem; color: #7f1d1d;">詳細なエラー情報</summary>
                                <p style="margin: 0.5rem 0 0 0; font-size: 0.8rem; color: #7f1d1d; font-family: monospace;">${error.message}</p>
                            </details>
                        </div>
                    `;
                }
            }
        }
        
        function displaySessionCosts(sessionCosts, tabType = 'analysis') {
            const container = tabType === 'analysis' ? 
                document.getElementById('costsAnalysisResult') : 
                document.getElementById('costsGraphResult');
            
            if (container) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: #f8fafc; border-radius: 8px;">
                        <h3 style="margin: 0 0 1rem 0; color: #374151;">💰 セッション使用料金</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem;">
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">Whisper</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #059669;">$${sessionCosts.whisper.toFixed(4)}</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">GPT</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #0369a1;">$${sessionCosts.gpt.toFixed(4)}</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">合計</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #dc2626;">$${sessionCosts.total.toFixed(4)}</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        }
        
        function displayPeriodCosts(costs, period, tabType = 'analysis') {
            const container = tabType === 'analysis' ? 
                document.getElementById('costsAnalysisResult') : 
                document.getElementById('costsGraphResult');
            
            const totalWhisper = costs.reduce((sum, cost) => sum + cost.whisperCost, 0);
            const totalGpt = costs.reduce((sum, cost) => sum + cost.gptCost, 0);
            const totalCost = costs.reduce((sum, cost) => sum + cost.totalCost, 0);
            
            const periodNames = {
                'today': '本日',
                'week': '過去7日間',
                'month': '過去30日間'
            };
            
            if (container) {
                container.innerHTML = `
                    <div style="padding: 1rem; background: #f8fafc; border-radius: 8px;">
                        <h3 style="margin: 0 0 1rem 0; color: #374151;">💰 ${periodNames[period]}の使用料金</h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 1rem; margin-bottom: 1rem;">
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">Whisper</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #059669;">$${totalWhisper.toFixed(4)}</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">GPT</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #0369a1;">$${totalGpt.toFixed(4)}</div>
                            </div>
                            <div style="text-align: center; padding: 0.5rem; background: white; border-radius: 6px; border: 1px solid #e2e8f0;">
                                <div style="font-size: 0.9rem; color: #6b7280;">合計</div>
                                <div style="font-size: 1.1rem; font-weight: 600; color: #dc2626;">$${totalCost.toFixed(4)}</div>
                            </div>
                        </div>
                        <div style="font-size: 0.9rem; color: #6b7280;">処理件数: ${costs.length}件</div>
                    </div>
                `;
            }
        }
        
        // グラフ表示用の関数
        function displaySessionGraph(sessionCosts) {
            // セッション表示は削除
        }
        
        function displayPeriodGraph(costs, period) {
            const canvas = document.getElementById('costsChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // キャンバスをクリア
            ctx.clearRect(0, 0, width, height);
            
            const periodNames = {
                'today': '本日',
                'week': '週間',
                'month': '月間'
            };
            
            if (period === 'today') {
                // 本日の場合は時間別に集計
                const hourData = {};
                // 0時から23時までのデータを初期化
                for (let i = 0; i < 24; i++) {
                    hourData[i] = { whisper: 0, gpt: 0, total: 0 };
                }
                
                costs.forEach(cost => {
                    const hour = new Date(cost.timestamp).getHours();
                    hourData[hour].whisper += cost.whisperCost;
                    hourData[hour].gpt += cost.gptCost;
                    hourData[hour].total += cost.totalCost;
                });
                
                // 24時間すべて表示
                const hours = Array.from({length: 24}, (_, i) => i);
                const labels = hours.map(h => `${h}時`);
                
                drawLineChart(ctx, labels, hourData, width, height, `${periodNames[period]}の時間別使用料金`, period);
            } else {
                // 週間・月間の場合は日付別に集計
                const dateData = {};
                costs.forEach(cost => {
                    // dateフィールドを優先、なければtimestampから抽出
                    const date = cost.date || (cost.timestamp ? cost.timestamp.split('T')[0] : null);
                    if (!date) {
                        console.warn('Cost entry missing date/timestamp:', cost);
                        return;
                    }
                    
                    if (!dateData[date]) {
                        dateData[date] = { whisper: 0, gpt: 0, total: 0 };
                    }
                    dateData[date].whisper += cost.whisperCost || 0;
                    dateData[date].gpt += cost.gptCost || 0;
                    dateData[date].total += cost.totalCost || 0;
                });
                
                // 日付でソート
                const sortedDates = Object.keys(dateData).sort();
                
                console.log(`${period} period - dates:`, sortedDates, 'data:', dateData);
                console.log(`${period} costs data:`, costs);
                // ラベル形式を調整（日付のみ表示）
                const formattedLabels = sortedDates.map(date => date.substring(5)); // MM-DD形式
                const formattedData = {};
                sortedDates.forEach((date, index) => {
                    formattedData[index] = dateData[date];
                });
                drawLineChart(ctx, formattedLabels, formattedData, width, height, `${periodNames[period]}使用料金`, period);
            }
        }
        
        function drawLineChart(ctx, labels, data, width, height, title, period) {
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding - 30;
            
            // タイトルを描画
            ctx.fillStyle = '#374151';
            ctx.font = '14px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(title, width / 2, 20);
            
            if (labels.length === 0) {
                ctx.fillStyle = '#6b7280';
                ctx.font = '12px sans-serif';
                ctx.fillText('データがありません', width / 2, height / 2);
                return;
            }
            
            // データのキーを取得（数値または日付文字列）
            const dataKeys = Object.keys(data);
            
            // 最大値を計算
            const maxTotal = Math.max(...dataKeys.map(key => data[key].total || 0));
            
            // 軸を描画
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding + 30);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Y軸の目盛りを描画
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + 30 + (chartHeight / ySteps) * i;
                const value = maxTotal * (1 - i / ySteps);
                
                ctx.fillStyle = '#6b7280';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(`$${value.toFixed(3)}`, padding - 5, y + 3);
                
                // グリッドライン
                ctx.strokeStyle = '#f3f4f6';
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // データポイントの座標を計算
            const xStep = chartWidth / (labels.length - 1 || 1);
            const points = {
                whisper: [],
                gpt: [],
                total: []
            };
            
            labels.forEach((label, index) => {
                const x = padding + index * xStep;
                // periodがtodayの場合は時間（index）をキーに、それ以外はインデックスをキーに使用
                let currentData;
                if (period === 'today') {
                    // 本日の場合、labelから時間を抽出
                    const hour = parseInt(label.replace('時', ''));
                    currentData = data[hour] || { whisper: 0, gpt: 0, total: 0 };
                } else {
                    // 週間・月間の場合はインデックスを使用
                    currentData = data[index] || { whisper: 0, gpt: 0, total: 0 };
                }
                
                const yWhisper = maxTotal > 0 ? height - padding - (currentData.whisper / maxTotal) * chartHeight : height - padding;
                const yGpt = maxTotal > 0 ? height - padding - (currentData.gpt / maxTotal) * chartHeight : height - padding;
                const yTotal = maxTotal > 0 ? height - padding - (currentData.total / maxTotal) * chartHeight : height - padding;
                
                points.whisper.push({ x, y: yWhisper });
                points.gpt.push({ x, y: yGpt });
                points.total.push({ x, y: yTotal });
                
                // X軸ラベル（期間に応じて表示頻度を調整）
                let shouldShowLabel = true;
                if (period === 'today') {
                    // 本日の場合、3時間ごとに表示（0, 3, 6, 9, 12, 15, 18, 21時）
                    shouldShowLabel = index % 3 === 0;
                } else if (period === 'week' && labels.length > 7) {
                    // 週間の場合、7個以上なら適度に間引く
                    shouldShowLabel = index % Math.ceil(labels.length / 7) === 0 || index === labels.length - 1;
                } else if (period === 'month' && labels.length > 15) {
                    // 月間の場合、15個以上なら適度に間引く
                    shouldShowLabel = index % Math.ceil(labels.length / 10) === 0 || index === labels.length - 1;
                }
                
                if (shouldShowLabel) {
                    ctx.fillStyle = '#6b7280';
                    ctx.font = '9px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.save();
                    ctx.translate(x, height - padding + 15);
                    ctx.rotate(-Math.PI / 4);
                    ctx.fillText(label, 0, 0);
                    ctx.restore();
                }
            });
            
            // 線を描画
            const lines = [
                { points: points.whisper, color: '#059669', label: 'Whisper' },
                { points: points.gpt, color: '#0369a1', label: 'GPT' },
                { points: points.total, color: '#dc2626', label: '合計' }
            ];
            
            lines.forEach(line => {
                // 線を描画
                ctx.strokeStyle = line.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                line.points.forEach((point, index) => {
                    if (index === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.stroke();
                
                // データポイントを描画
                line.points.forEach(point => {
                    ctx.fillStyle = line.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            
            // 凡例を描画
            const legendY = 40;
            lines.forEach((line, index) => {
                const legendX = width - 100;
                ctx.fillStyle = line.color;
                ctx.fillRect(legendX, legendY + index * 15, 10, 10);
                ctx.fillStyle = '#374151';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(line.label, legendX + 15, legendY + index * 15 + 8);
            });
        }
        
        // ページ読み込み時の初期化
        document.addEventListener('DOMContentLoaded', function() {
            // セッション料金をデフォルト表示
            setTimeout(() => {
                loadCostsAnalysis();
                loadCostsGraph();
            }, 1000); // 1秒待ってからロード
        });
        
        // サーバー接続テスト関数
        async function testServerConnection() {
            try {
                const response = await fetch('/session-costs');
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // URL History Management Functions
        function getUrlHistory() {
            try {
                const historyString = localStorage.getItem('youtubeUrlHistory');
                console.log('Raw localStorage data:', historyString);
                const history = historyString ? JSON.parse(historyString) : [];
                console.log('Parsed URL history:', history);
                return history;
            } catch (error) {
                console.error('Error loading URL history:', error);
                return [];
            }
        }

        function saveUrlToHistory(url) {
            if (!url || !url.trim()) return;
            
            try {
                let history = getUrlHistory();
                
                // Remove the URL if it already exists (to avoid duplicates)
                history = history.filter(item => item.url !== url);
                
                // Add the new URL at the beginning (newest first)
                history.unshift({
                    url: url,
                    timestamp: new Date().toISOString(),
                    date: new Date().toLocaleDateString('ja-JP')
                });
                
                // Keep only the last 20 URLs
                if (history.length > 20) {
                    history = history.slice(0, 20);
                }
                
                localStorage.setItem('youtubeUrlHistory', JSON.stringify(history));
                updateUrlSuggestions();
            } catch (error) {
                console.error('Error saving URL to history:', error);
            }
        }

        function updateUrlSuggestions() {
            try {
                const datalist = document.getElementById('urlHistory');
                if (!datalist) {
                    console.warn('urlHistory datalist element not found');
                    return;
                }
                
                // Clear existing options
                datalist.innerHTML = '';
                
                const history = getUrlHistory();
                console.log('URL History loaded:', history);
                
                if (history.length === 0) {
                    console.log('No URL history found');
                    return;
                }
                
                // Add each URL as an option (newest first)
                history.forEach((item, index) => {
                    const option = document.createElement('option');
                    option.value = item.url;
                    option.textContent = `${item.url} (${item.date})`;
                    datalist.appendChild(option);
                    console.log(`Added URL option ${index + 1}:`, item.url);
                });
                
                console.log(`Updated ${history.length} URL suggestions`);
            } catch (error) {
                console.error('Error updating URL suggestions:', error);
            }
        }

        function clearUrlHistory() {
            try {
                localStorage.removeItem('youtubeUrlHistory');
                updateUrlSuggestions();
                console.log('URL history cleared');
            } catch (error) {
                console.error('Error clearing URL history:', error);
            }
        }
        
        // Debug functions for testing (available in console)
        window.debugUrlHistory = {
            show: () => {
                console.log('Current URL History:', getUrlHistory());
            },
            add: (url) => {
                saveUrlToHistory(url);
                console.log('Added URL:', url);
            },
            clear: () => {
                clearUrlHistory();
            },
            refresh: () => {
                updateUrlSuggestions();
            }
        };

        // Initialize URL suggestions and button state when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMContentLoaded: Initializing URL suggestions and button state');
            updateUrlSuggestions();
            updateUploadButtonText();
            
            // URL入力フィールドの変更を監視
            const urlInput = document.getElementById('youtubeUrl');
            if (urlInput) {
                urlInput.addEventListener('input', function() {
                    checkContentForCurrentUrl();
                });
                urlInput.addEventListener('blur', function() {
                    checkContentForCurrentUrl();
                });
            }
        });
        
        // Also try to initialize after a short delay for safety
        window.addEventListener('load', function() {
            setTimeout(() => {
                console.log('Window load: Re-initializing URL suggestions and button state');
                updateUrlSuggestions();
                updateUploadButtonText();
            }, 100);
        });
    </script>
</body>
</html>
