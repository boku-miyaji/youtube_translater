# å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œ: MOV/MP4å½¢å¼ã®å‹•ç”»è§£æã‚µãƒãƒ¼ãƒˆ

## ãƒ•ãƒ­ãƒ³ãƒˆãƒã‚¿ãƒ¼
- **Issue**: 18
- **Title**: å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œ: MOV/MP4å½¢å¼ã®å‹•ç”»è§£æã‚µãƒãƒ¼ãƒˆ
- **Type**: Feature
- **Description**: youtubeã®å‹•ç”»ã®ã¿ã§ã¯ãªãã€movã‚„mp4ãªã©ã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚å¯¾è±¡ã«ã„ã‚Œã€åŒæ§˜ã®è§£æãŒã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹

## æ¦‚è¦ãƒ»è¦ä»¶åˆ†æ

### ğŸ¯ ç›®æ¨™
YouTubeå‹•ç”»ã«åŠ ãˆã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«ã®å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆMOV/MP4ï¼‰ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã€åŒæ§˜ã®è§£ææ©Ÿèƒ½ï¼ˆæ–‡å­—èµ·ã“ã—ã€è¦ç´„ã€è¨˜äº‹ç”Ÿæˆï¼‰ã‚’æä¾›ã™ã‚‹ã€‚

### ğŸ“‹ æ©Ÿèƒ½è¦ä»¶

#### å¿…é ˆæ©Ÿèƒ½
1. **å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰**
   - MOV/MP4å½¢å¼ã®ã‚µãƒãƒ¼ãƒˆ
   - ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
   - ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤º
   - ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

2. **å‹•ç”»è§£ææ©Ÿèƒ½**
   - æ–‡å­—èµ·ã“ã—ï¼ˆWhisper APIä½¿ç”¨ï¼‰
   - è¦ç´„ç”Ÿæˆ
   - è¨˜äº‹ç”Ÿæˆ
   - ãƒãƒ£ãƒƒãƒˆæ©Ÿèƒ½

3. **ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†**
   - ä¸€æ™‚çš„ãªå‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
   - å‡¦ç†å®Œäº†å¾Œã®è‡ªå‹•å‰Šé™¤
   - ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™

#### éæ©Ÿèƒ½è¦ä»¶
1. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**
   - æœ€å¤§ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚º: 500MB
   - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ™‚é–“: 10åˆ†ä»¥å†…
   - å‡¦ç†æ™‚é–“: å‹•ç”»æ™‚é–“ã®2-3å€ä»¥å†…

2. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - ãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼æ¤œè¨¼
   - ã‚¦ã‚¤ãƒ«ã‚¹ã‚¹ã‚­ãƒ£ãƒ³
   - ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«è‡ªå‹•å‰Šé™¤
   - ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

3. **å¯ç”¨æ€§**
   - ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¤±æ•—æ™‚ã®å†è©¦è¡Œ
   - å‡¦ç†ä¸­æ–­æ™‚ã®çŠ¶æ…‹ä¿æŒ
   - ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

## æŠ€è¡“è¨­è¨ˆ

### ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Frontend      â”‚    â”‚   Backend       â”‚    â”‚   Storage       â”‚
â”‚                 â”‚    â”‚                 â”‚    â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚File Upload  â”‚ â”‚â”€â”€â”€â–¶â”‚ â”‚File Handler â”‚ â”‚â”€â”€â”€â–¶â”‚ â”‚Temp Storage â”‚ â”‚
â”‚ â”‚Component    â”‚ â”‚    â”‚ â”‚             â”‚ â”‚    â”‚ â”‚             â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                 â”‚    â”‚        â”‚        â”‚    â”‚                 â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚Analysis UI  â”‚ â”‚â—€â”€â”€â”€â”‚ â”‚Video        â”‚ â”‚â”€â”€â”€â–¶â”‚ â”‚Processed    â”‚ â”‚
â”‚ â”‚             â”‚ â”‚    â”‚ â”‚Processor    â”‚ â”‚    â”‚ â”‚Data         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ”§ å®Ÿè£…è©³ç´°

#### 1. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰å®Ÿè£…

**æ–°è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
```typescript
// components/VideoFileUpload.tsx
interface VideoFileUploadProps {
  onFileSelected: (file: File) => void;
  maxSize: number;
  acceptedFormats: string[];
  isUploading: boolean;
  uploadProgress: number;
}

interface VideoFile {
  file: File;
  id: string;
  name: string;
  size: number;
  duration?: number;
  thumbnail?: string;
}
```

**æ—¢å­˜ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆä¿®æ­£**
```typescript
// pages/AnalyzePage.tsx
// URLã¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ä¸¡æ–¹ã«å¯¾å¿œ
interface AnalyzePageState {
  inputType: 'url' | 'file';
  youtubeUrl?: string;
  videoFile?: VideoFile;
  isProcessing: boolean;
  progress: ProcessingProgress;
}
```

#### 2. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…

**æ–°è¦APIã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ**
```typescript
// /api/upload-video-file
POST /api/upload-video-file
Content-Type: multipart/form-data
Body: {
  file: File,
  options: {
    language: string,
    model: string,
    generateSummary: boolean,
    generateArticle: boolean
  }
}

Response: {
  fileId: string,
  originalName: string,
  size: number,
  duration: number,
  status: 'uploaded' | 'processing' | 'completed' | 'failed'
}
```

**å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³**
```typescript
// services/VideoFileProcessor.ts
class VideoFileProcessor {
  async processVideoFile(file: File): Promise<ProcessingResult> {
    // 1. ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼
    await this.validateFile(file);
    
    // 2. ä¸€æ™‚ä¿å­˜
    const tempPath = await this.saveTempFile(file);
    
    // 3. ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æŠ½å‡º
    const metadata = await this.extractMetadata(tempPath);
    
    // 4. æ–‡å­—èµ·ã“ã—
    const transcript = await this.transcribeVideo(tempPath);
    
    // 5. è¦ç´„ãƒ»è¨˜äº‹ç”Ÿæˆ
    const analysis = await this.generateAnalysis(transcript);
    
    // 6. ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«å‰Šé™¤
    await this.cleanupTempFile(tempPath);
    
    return {
      metadata,
      transcript,
      analysis,
      costs: this.calculateCosts(metadata, transcript, analysis)
    };
  }
}
```

#### 3. ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸è¨­è¨ˆ

**ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜**
```typescript
// utils/FileStorage.ts
interface TempFileConfig {
  maxSize: number;          // 500MB
  allowedTypes: string[];   // ['video/mp4', 'video/quicktime']
  retentionTime: number;    // 24æ™‚é–“
  cleanupInterval: number;  // 1æ™‚é–“
}

class TempFileManager {
  private tempDir = process.env.TEMP_UPLOAD_DIR || '/tmp/uploads';
  
  async saveFile(file: File): Promise<string> {
    const filename = `${Date.now()}-${crypto.randomUUID()}.${this.getExtension(file)}`;
    const filepath = path.join(this.tempDir, filename);
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
    await fs.writeFile(filepath, file.stream());
    
    // è‡ªå‹•å‰Šé™¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    this.scheduleCleanup(filepath);
    
    return filepath;
  }
  
  async cleanupExpiredFiles(): Promise<void> {
    // 24æ™‚é–“ä»¥ä¸Šå‰ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
  }
}
```

### ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«

#### æ—¢å­˜ãƒ¢ãƒ‡ãƒ«æ‹¡å¼µ
```typescript
// types/VideoMetadata.ts
interface VideoMetadata {
  // æ—¢å­˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  videoId?: string;        // YouTube video ID (optional)
  title: string;
  duration: number;
  views?: number;          // YouTube only
  channel?: string;        // YouTube only
  
  // æ–°è¦ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  source: 'youtube' | 'file';
  fileId?: string;         // File upload ID
  originalFilename?: string;
  fileSize?: number;       // bytes
  uploadedAt?: string;     // ISO timestamp
  
  // å…±é€šãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
  transcriptSource: 'youtube' | 'whisper';
  costs: DetailedCosts;
  analysisTime: AnalysisTimeInfo;
}
```

#### æ–°è¦ãƒ¢ãƒ‡ãƒ«
```typescript
// types/VideoFile.ts
interface VideoFileUpload {
  id: string;
  originalName: string;
  size: number;
  mimeType: string;
  uploadedAt: string;
  status: 'uploaded' | 'processing' | 'completed' | 'failed' | 'deleted';
  tempPath: string;
  processingResult?: ProcessingResult;
  error?: string;
}

interface ProcessingResult {
  metadata: VideoMetadata;
  transcript: TranscriptSegment[];
  summary?: string;
  article?: string;
  costs: DetailedCosts;
  analysisTime: AnalysisTimeInfo;
}
```

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ğŸ§ª ãƒ†ã‚¹ãƒˆã‚«ãƒ†ã‚´ãƒª

#### 1. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ
```typescript
// tests/VideoFileProcessor.test.ts
describe('VideoFileProcessor', () => {
  describe('validateFile', () => {
    test('should accept valid MP4 file', async () => {
      const file = createMockFile('video.mp4', 'video/mp4', 100 * 1024 * 1024);
      await expect(processor.validateFile(file)).resolves.not.toThrow();
    });
    
    test('should reject oversized file', async () => {
      const file = createMockFile('large.mp4', 'video/mp4', 600 * 1024 * 1024);
      await expect(processor.validateFile(file)).rejects.toThrow('File too large');
    });
    
    test('should reject invalid file type', async () => {
      const file = createMockFile('video.avi', 'video/avi', 100 * 1024 * 1024);
      await expect(processor.validateFile(file)).rejects.toThrow('Unsupported file type');
    });
  });
});
```

#### 2. çµ±åˆãƒ†ã‚¹ãƒˆ
```typescript
// tests/integration/VideoFileUpload.test.ts
describe('Video File Upload Flow', () => {
  test('should process complete video file upload', async () => {
    // 1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    const uploadResponse = await request(app)
      .post('/api/upload-video-file')
      .attach('file', 'tests/fixtures/sample.mp4')
      .expect(200);
    
    // 2. å‡¦ç†å®Œäº†ã¾ã§å¾…æ©Ÿ
    await waitForProcessing(uploadResponse.body.fileId);
    
    // 3. çµæœç¢ºèª
    const result = await request(app)
      .get(`/api/processing-result/${uploadResponse.body.fileId}`)
      .expect(200);
    
    expect(result.body.transcript).toBeDefined();
    expect(result.body.summary).toBeDefined();
    expect(result.body.costs).toBeDefined();
  });
});
```

#### 3. E2Eãƒ†ã‚¹ãƒˆ
```typescript
// tests/e2e/VideoFileAnalysis.test.ts
describe('Video File Analysis E2E', () => {
  test('should analyze uploaded video file', async () => {
    await page.goto('/analyze');
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    await page.setInputFiles('input[type="file"]', 'tests/fixtures/sample.mp4');
    
    // åˆ†æé–‹å§‹
    await page.click('[data-testid="analyze-button"]');
    
    // çµæœç¢ºèª
    await expect(page.locator('[data-testid="transcript"]')).toBeVisible();
    await expect(page.locator('[data-testid="summary"]')).toBeVisible();
    await expect(page.locator('[data-testid="cost-info"]')).toBeVisible();
  });
});
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ»ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®äº‹é …

### ğŸ”’ ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¯¾ç­–

#### 1. ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼
```typescript
// security/FileValidator.ts
class FileValidator {
  private allowedMimeTypes = ['video/mp4', 'video/quicktime'];
  private maxFileSize = 500 * 1024 * 1024; // 500MB
  
  async validateFile(file: File): Promise<void> {
    // MIMEã‚¿ã‚¤ãƒ—ãƒã‚§ãƒƒã‚¯
    if (!this.allowedMimeTypes.includes(file.type)) {
      throw new Error('Unsupported file type');
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯
    if (file.size > this.maxFileSize) {
      throw new Error('File too large');
    }
    
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚°ãƒãƒãƒ£æ¤œè¨¼
    await this.validateFileSignature(file);
    
    // ã‚¦ã‚¤ãƒ«ã‚¹ã‚¹ã‚­ãƒ£ãƒ³ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    await this.scanForVirus(file);
  }
  
  private async validateFileSignature(file: File): Promise<void> {
    const buffer = await file.arrayBuffer();
    const signature = new Uint8Array(buffer.slice(0, 12));
    
    // MP4 signature check
    if (signature[4] === 0x66 && signature[5] === 0x74 && signature[6] === 0x79 && signature[7] === 0x70) {
      return; // Valid MP4
    }
    
    throw new Error('Invalid file signature');
  }
}
```

#### 2. ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡
```typescript
// middleware/FileAccessControl.ts
export const fileAccessMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const fileId = req.params.fileId;
  const userId = req.user?.id;
  
  // ãƒ•ã‚¡ã‚¤ãƒ«ã®æ‰€æœ‰è€…ç¢ºèª
  if (!isFileOwner(fileId, userId)) {
    return res.status(403).json({ error: 'Access denied' });
  }
  
  next();
};
```

#### 3. ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†
```typescript
// security/TempFileCleanup.ts
class TempFileCleanup {
  private cleanupInterval = 60 * 60 * 1000; // 1æ™‚é–“
  private maxFileAge = 24 * 60 * 60 * 1000; // 24æ™‚é–“
  
  startCleanupScheduler(): void {
    setInterval(() => {
      this.cleanupExpiredFiles();
    }, this.cleanupInterval);
  }
  
  private async cleanupExpiredFiles(): Promise<void> {
    const tempDir = process.env.TEMP_UPLOAD_DIR || '/tmp/uploads';
    const files = await fs.readdir(tempDir);
    
    for (const file of files) {
      const filepath = path.join(tempDir, file);
      const stats = await fs.stat(filepath);
      
      if (Date.now() - stats.mtimeMs > this.maxFileAge) {
        await fs.unlink(filepath);
        console.log(`Cleaned up expired file: ${filepath}`);
      }
    }
  }
}
```

### âš¡ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### 1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æœ€é©åŒ–
```typescript
// utils/FileUploadOptimizer.ts
class FileUploadOptimizer {
  async optimizeUpload(file: File): Promise<void> {
    // ãƒãƒ£ãƒ³ã‚¯ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
    const chunkSize = 1024 * 1024; // 1MB chunks
    const chunks = Math.ceil(file.size / chunkSize);
    
    for (let i = 0; i < chunks; i++) {
      const start = i * chunkSize;
      const end = Math.min(start + chunkSize, file.size);
      const chunk = file.slice(start, end);
      
      await this.uploadChunk(chunk, i, chunks);
    }
  }
  
  private async uploadChunk(chunk: Blob, index: number, total: number): Promise<void> {
    // ä¸¦è¡Œã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰åˆ¶å¾¡
    // ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½
    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹æ›´æ–°
  }
}
```

#### 2. å‡¦ç†ã‚­ãƒ¥ãƒ¼ç®¡ç†
```typescript
// queue/VideoProcessingQueue.ts
class VideoProcessingQueue {
  private queue: Queue<VideoProcessingJob>;
  private concurrency = 3; // åŒæ™‚å‡¦ç†æ•°
  
  constructor() {
    this.queue = new Queue('video-processing', {
      concurrency: this.concurrency,
      timeout: 30 * 60 * 1000, // 30åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
    });
  }
  
  async addJob(fileId: string, options: ProcessingOptions): Promise<void> {
    await this.queue.add('process-video', {
      fileId,
      options,
      attempts: 3,
      backoff: 'exponential'
    });
  }
}
```

## æœªè§£æ±ºã®è¨­è¨ˆèª²é¡Œ

### ğŸ¤” æ¤œè¨ãŒå¿…è¦ãªé …ç›®

1. **ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸æˆ¦ç•¥**
   - ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ vs ã‚¯ãƒ©ã‚¦ãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
   - ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜å ´æ‰€
   - ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆæ™‚ã®è€ƒæ…®

2. **å‡¦ç†èƒ½åŠ›**
   - åŒæ™‚ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ•°ã®åˆ¶é™
   - å‡¦ç†ã‚­ãƒ¥ãƒ¼ã®ç®¡ç†
   - ãƒªã‚½ãƒ¼ã‚¹ä½¿ç”¨é‡ã®åˆ¶å¾¡

3. **ã‚³ã‚¹ãƒˆç®¡ç†**
   - Whisper APIä½¿ç”¨æ–™é‡‘ã®è¨ˆç®—
   - ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚³ã‚¹ãƒˆã®è¦‹ç©ã‚‚ã‚Š
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¥ã®ä½¿ç”¨é‡åˆ¶é™

4. **ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°**
   - å‡¦ç†ä¸­æ–­æ™‚ã®ãƒªã‚«ãƒãƒª
   - éƒ¨åˆ†çš„ãªå¤±æ•—ã®å‡¦ç†
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®é©åˆ‡ãªãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

5. **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**
   - å¤§é‡ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å¯¾å¿œ
   - å‡¦ç†èƒ½åŠ›ã®å‹•çš„ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
   - ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®åˆ†æ•£åŒ–

### ğŸ¯ æ¬¡ãƒ•ã‚§ãƒ¼ã‚ºã§ã®å¯¾å¿œäºˆå®š

1. **Phase 1**: åŸºæœ¬çš„ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½
2. **Phase 2**: å‡¦ç†æœ€é©åŒ–ã¨ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
3. **Phase 3**: ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£å‘ä¸Šã¨ã‚³ã‚¹ãƒˆæœ€é©åŒ–

## å®Ÿè£…å„ªå…ˆé †ä½

### ğŸ¥‡ é«˜å„ªå…ˆåº¦
1. ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ UI
2. ãƒ•ã‚¡ã‚¤ãƒ«æ¤œè¨¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
3. åŸºæœ¬çš„ãªå‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
4. ä¸€æ™‚ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†

### ğŸ¥ˆ ä¸­å„ªå…ˆåº¦
1. å‡¦ç†ã‚­ãƒ¥ãƒ¼ç®¡ç†
2. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°å¼·åŒ–
3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
4. è©³ç´°ãªãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸

### ğŸ¥‰ ä½å„ªå…ˆåº¦
1. é«˜åº¦ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã‚µãƒãƒ¼ãƒˆ
2. ä¸¦åˆ—å‡¦ç†æœ€é©åŒ–
3. è©³ç´°ãªä½¿ç”¨é‡åˆ†æ
4. ç®¡ç†ç”»é¢æ©Ÿèƒ½

---

ã“ã®è¨­è¨ˆæ›¸ã¯å‹•ç”»ãƒ•ã‚¡ã‚¤ãƒ«å¯¾å¿œæ©Ÿèƒ½ã®åŒ…æ‹¬çš„ãªå®Ÿè£…è¨ˆç”»ã‚’æä¾›ã—ã¾ã™ã€‚ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã€ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£ã‚’è€ƒæ…®ã—ãŸå …ç‰¢ãªå®Ÿè£…ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚