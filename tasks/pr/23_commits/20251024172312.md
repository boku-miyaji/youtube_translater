# Commit: Historical Data Tracking for Time Estimation

**Commit Hash**: 5531413
**Date**: 2025-10-24 17:23:12
**Branch**: feature/implement-23

## 背景

ユーザーからの要望：
> 推論時間は過去のものを参考にして推定時間を出して。文字起こしと要約作成に分けてちゃんと記録して。動画と文書の解析で推論ロジックが違うので分けて推定時間を出して。

**翻訳:**
- 過去のデータを使って処理時間を推定する
- 文字起こしと要約作成を分けて記録する
- 動画と文書で異なる推定ロジックを使用する

## 問題分析

### 問題1: PDFの履歴データが記録されていない

**現状:**
```typescript
// PDF endpoint (/api/analyze-pdf) には analysisProgressDB の呼び出しがない
// → 履歴データが蓄積されない
// → 推定時間が常にデフォルト値
// → 経験から学習しない
```

**影響:**
- PDFを何回処理しても推定時間が改善されない
- 「過去の実績から算出」バッジが表示されない
- ユーザーは常に不正確なデフォルト推定を見る

### 問題2: PDF contentTypeStats の計算が間違っている

**現状:**
```typescript
// analysis-progress.ts の calculateContentTypeStats()
const transcriptionAverage = records.reduce((sum, r) =>
  sum + r.transcriptionDuration / (r.contentDuration / 60), 0) / records.length;
// ↑ 全てのコンテンツタイプで「秒/分」計算
// PDF の contentDuration はページ数なのに、60で割っている ← 間違い！
```

**具体例:**
```
10ページのPDF、抽出時間15秒の場合:
  contentDuration = 10 (ページ数)
  transcriptionDuration = 15 (秒)

  計算: 15 / (10 / 60) = 15 / 0.167 = 90秒/分 ← 意味不明
  正解: 15 / 10 = 1.5秒/ページ ← 正しい
```

**影響:**
- PDF統計が完全に間違った値になる
- 推定時間が実際と大きく乖離
- 履歴データがあっても使えない

### 問題3: 文字起こしと要約が分けて記録されていない（PDFのみ）

**現状:**
- YouTube/Audio: ✅ 文字起こしと要約を分けて記録
- PDF: ❌ 記録自体がない

**ユーザーの要望:**
> 文字起こしと要約作成に分けてちゃんと記録して

**必要性:**
- どの処理に時間がかかっているか分析できる
- ボトルネック特定が可能
- モデル別の性能比較ができる

## 実装内容

### 1. PDF contentTypeStats の修正

**ファイル:** `src/database/analysis-progress.ts`

**Before:**
```typescript
const transcriptionAverage = records.reduce((sum, r) =>
  sum + r.transcriptionDuration / (r.contentDuration / 60), 0) / records.length;
// 全てのコンテンツタイプで同じ計算
```

**After:**
```typescript
if (contentType === 'pdf') {
  // For PDF: contentDuration represents page count, not seconds
  // Calculate seconds per page
  const transcriptionAverage = records.reduce((sum, r) =>
    sum + r.transcriptionDuration / r.contentDuration, 0) / records.length;
  // ↑ ページ数で割る（60で割らない）

  contentTypeStats[contentType] = {
    transcriptionAverage, // seconds per page
    summaryAverage,       // seconds per page
    sampleSize: records.length
  };
} else {
  // For video/audio: contentDuration is in seconds, calculate seconds per minute
  const transcriptionAverage = records.reduce((sum, r) =>
    sum + r.transcriptionDuration / (r.contentDuration / 60), 0) / records.length;
  // ↑ 秒→分に変換してから割る

  contentTypeStats[contentType] = {
    transcriptionAverage, // seconds per minute
    summaryAverage,       // seconds per minute
    sampleSize: records.length
  };
}
```

**ポイント:**
- PDF: `contentDuration` = ページ数 → `秒/ページ`で計算
- Video/Audio: `contentDuration` = 秒 → `秒/分`で計算
- コメントで単位を明示

### 2. PDFエンドポイントへの履歴記録追加

**ファイル:** `src/server.ts` (/api/analyze-pdf)

#### 2-1. 進捗レコードの作成

**追加箇所:** PDF text extraction 直後

```typescript
// Create progress tracking record
// IMPORTANT: For PDF, contentDuration represents page count, not seconds
let progressId: string | undefined; // Declare outside try-catch for error handling

try {
  progressId = analysisProgressDB.createRecord(
    'pdf',
    pdfContent.pageCount,  // Use page count as "duration" for PDF
    'pdf-parse',           // PDF doesn't use Whisper, just text extraction
    gptModel,
    pdfContent.fullText.length, // Content length in characters
    undefined,             // No audio quality for PDF
    language
  );
  console.log(`📊 Created progress tracking record: ${progressId}`);
} catch (err) {
  console.warn('Failed to create progress tracking record:', err);
}
```

**ポイント:**
- `contentDuration` にページ数を渡す（秒ではない）
- `transcriptionModel` に `'pdf-parse'` を指定（Whisperではない）
- エラーハンドリングで try-catch 使用

#### 2-2. 抽出時間の記録

**追加箇所:** PDF text extraction 完了後

```typescript
// Update transcription (extraction) progress
if (progressId) {
  try {
    analysisProgressDB.updateTranscriptionProgress(
      progressId,
      extractionStartTime.toISOString(),
      extractionEndTime.toISOString()
    );
    console.log(`📊 Updated extraction progress: ${extractionDuration}s for ${pdfContent.pageCount} pages`);
  } catch (err) {
    console.warn('Failed to update extraction progress:', err);
  }
}
```

**記録内容:**
- 抽出開始時刻
- 抽出終了時刻
- 自動計算される抽出時間（秒）

#### 2-3. 要約時間の記録（開始）

**追加箇所:** Summary generation 開始時

```typescript
// Update summary progress - start time
if (progressId) {
  try {
    analysisProgressDB.updateSummaryProgress(progressId, summaryStartTime.toISOString());
  } catch (err) {
    console.warn('Failed to update summary progress (start):', err);
  }
}
```

#### 2-4. 要約時間の記録（終了・成功時）

**追加箇所:** Summary generation 成功後

```typescript
// Update summary progress - end time
if (progressId && summaryStartTime) {
  try {
    analysisProgressDB.updateSummaryProgress(
      progressId,
      summaryStartTime.toISOString(),
      summaryEndTime.toISOString()
    );
    const summaryDurationForLog = Math.round((summaryEndTime.getTime() - summaryStartTime.getTime()) / 1000);
    console.log(`📊 Updated summary progress: ${summaryDurationForLog}s`);
  } catch (err) {
    console.warn('Failed to update summary progress (end):', err);
  }
}
```

#### 2-5. 要約時間の記録（終了・エラー時）

**追加箇所:** Summary generation エラー後（fallback summary）

```typescript
// Update summary progress - end time (even on error)
if (progressId && summaryStartTime) {
  try {
    analysisProgressDB.updateSummaryProgress(
      progressId,
      summaryStartTime.toISOString(),
      summaryEndTime.toISOString()
    );
  } catch (err) {
    console.warn('Failed to update summary progress (error case):', err);
  }
}
```

**ポイント:**
- エラー時でも要約時間を記録
- Fallback summaryの時間も統計に含まれる

#### 2-6. 分析完了の記録（成功時）

**追加箇所:** Response 送信直前

```typescript
// Complete progress tracking
if (progressId) {
  try {
    analysisProgressDB.completeAnalysis(progressId, true);
    console.log(`📊 Completed progress tracking: ${progressId}`);
  } catch (err) {
    console.warn('Failed to complete progress tracking:', err);
  }
}
```

#### 2-7. 分析完了の記録（エラー時）

**追加箇所:** Error handling 内

```typescript
// Complete progress tracking with error
if (progressId) {
  try {
    analysisProgressDB.completeAnalysis(progressId, false, error instanceof Error ? error.message : 'Unknown error');
    console.log(`📊 Completed progress tracking with error: ${progressId}`);
  } catch (err) {
    console.warn('Failed to complete progress tracking (error case):', err);
  }
}
```

**ポイント:**
- エラー時は `success: false` で記録
- エラーメッセージも保存

### 3. スコープ修正

**問題:**
```typescript
try {
  let progressId: string | undefined;
  // ... processing ...
} catch (error) {
  // Cannot access progressId here! ❌
}
```

**修正:**
```typescript
let progressId: string | undefined; // Declare at function scope
try {
  progressId = analysisProgressDB.createRecord(...);
  // ... processing ...
} catch (error) {
  // Can access progressId for error tracking ✅
  analysisProgressDB.completeAnalysis(progressId, false, error.message);
}
```

**理由:**
- エラー時にも進捗を記録するため
- try-catch 外で宣言する必要がある

## データフロー

```
PDF Analysis Start
  ↓
createRecord(contentType='pdf', contentDuration=pageCount)
  → Record created in history/analysis-progress.json
  ↓
Extract PDF Text (pdfParse)
  ↓
updateTranscriptionProgress(startTime, endTime)
  → Extraction time recorded (e.g., 15 seconds for 10 pages)
  ↓
Generate Summary (GPT-4)
  ↓
updateSummaryProgress(startTime)
  → Summary start time recorded
  ↓
Summary Complete
  ↓
updateSummaryProgress(startTime, endTime)
  → Summary time recorded (e.g., 25 seconds)
  ↓
completeAnalysis(success=true)
  → Record marked as successful
  ↓
Data saved to history/analysis-progress.json
  ↓
Future estimates use this historical data
  → calculateProcessingTime() reads from analysisProgressDB.getAnalysisStats()
  → Uses PDF-specific stats with seconds per page
```

## 期待される効果

### 1. 履歴データの蓄積

**Before:**
```
PDF処理回数: 0回
推定時間: デフォルト (1.5秒/ページ)
信頼度: 低い (常にデフォルト)
```

**After (10回処理後):**
```json
{
  "contentTypeStats": {
    "pdf": {
      "transcriptionAverage": 1.2,  // 実測平均 1.2秒/ページ
      "summaryAverage": 2.5,        // 実測平均 2.5秒/ページ
      "sampleSize": 10              // 10個のサンプル
    }
  }
}
```

**推定時間:**
```
10ページのPDF:
  抽出: 1.2秒/ページ × 10 = 12秒
  要約: 2.5秒/ページ × 10 = 25秒
  合計: 37秒
  信頼度: 中〜高 (10サンプル)
  バッジ: "✓ 過去の実績から算出"
```

### 2. コンテンツタイプ別の正確な推定

**YouTube 動画 (10分):**
```
推定時間:
  文字起こし: 12秒/分 × 10分 = 120秒 (2分)
  要約: 30秒/分 × 10分 = 300秒 (5分)
  合計: 7分
  表示: "動画1分あたり12秒" / "動画1分あたり30秒"
```

**PDF (10ページ):**
```
推定時間:
  抽出: 1.2秒/ページ × 10 = 12秒
  要約: 2.5秒/ページ × 10 = 25秒
  合計: 37秒
  表示: "1.2秒/ページ" / "2.5秒/ページ"
```

### 3. 文字起こしと要約の分離

**分析結果の例:**
```
モデル別統計:
  gpt-4o-mini:
    要約速度: 2.5秒/ページ
    サンプル数: 10

  gpt-4o:
    要約速度: 4.5秒/ページ
    サンプル数: 5

→ gpt-4o-mini の方が1.8倍速い！
```

**ボトルネック特定:**
```
100ページのPDF:
  抽出時間: 120秒 (1.2秒/ページ × 100)
  要約時間: 250秒 (2.5秒/ページ × 100)

→ 要約生成がボトルネック（全体の67%）
→ GPTモデルの最適化が効果的
```

### 4. 経験から学習

**1回目の処理:**
```
推定: 1.5秒/ページ (デフォルト)
実際: 1.8秒/ページ
→ 20%のズレ
→ データを記録
```

**10回目の処理:**
```
推定: 1.75秒/ページ (履歴平均)
実際: 1.8秒/ページ
→ 3%のズレ
→ 精度向上！
```

## 技術的詳細

### 履歴データ構造

**history/analysis-progress.json:**
```json
{
  "id": "analysis_1634567890123_xyz",
  "contentType": "pdf",
  "contentDuration": 10,  // ページ数
  "transcriptionModel": "pdf-parse",
  "gptModel": "gpt-4o-mini",
  "transcriptionStartTime": "2025-10-24T08:00:00Z",
  "transcriptionEndTime": "2025-10-24T08:00:12Z",
  "transcriptionDuration": 12,  // 12秒
  "summaryStartTime": "2025-10-24T08:00:12Z",
  "summaryEndTime": "2025-10-24T08:00:37Z",
  "summaryDuration": 25,  // 25秒
  "contentLength": 5000,  // 文字数
  "success": true
}
```

### 統計計算

**PDF (contentType === 'pdf'):**
```typescript
// contentDuration = ページ数 (e.g., 10)
// transcriptionDuration = 抽出時間 (e.g., 12秒)
transcriptionAverage = 12 / 10 = 1.2秒/ページ
```

**YouTube (contentType === 'youtube'):**
```typescript
// contentDuration = 秒 (e.g., 600秒 = 10分)
// transcriptionDuration = 文字起こし時間 (e.g., 120秒)
transcriptionAverage = 120 / (600 / 60) = 120 / 10 = 12秒/分
```

### エラーハンドリング

**全ての履歴記録呼び出しに try-catch:**
```typescript
try {
  analysisProgressDB.createRecord(...);
} catch (err) {
  console.warn('Failed to create progress tracking record:', err);
  // エラーでも処理は継続（履歴記録は必須ではない）
}
```

**理由:**
- 履歴記録の失敗で処理全体を止めない
- メイン機能（PDF解析）は常に動作
- エラーログで問題を把握

## 検証

### ビルド
- ✅ `npm run build`: 成功
- ✅ `npm run type-check`: 成功

### 変更の安全性
- PDF endpoint に記録機能追加（既存機能への影響なし）
- contentTypeStats 計算修正（PDF統計が正確に）
- スコープ修正（エラーハンドリング改善）
- 後方互換性あり

### テスト推奨項目
- [ ] PDFを処理して history/analysis-progress.json にデータが記録されることを確認
- [ ] 2回目のPDF処理で履歴データが使われることを確認
- [ ] "✓ 過去の実績から算出" バッジが表示されることを確認
- [ ] PDF と YouTube で異なる表示単位（秒/ページ vs 動画1分あたり秒）を確認
- [ ] エラー時でも履歴データが記録されることを確認

## ファイル変更

1. `src/database/analysis-progress.ts`: PDF vs Video/Audio の計算分離
2. `src/server.ts`: PDF endpoint への履歴記録追加

**変更行数:**
- +124 insertions
- -19 deletions

## まとめ

ユーザーの要望「過去のデータを使って推定時間を出す」「文字起こしと要約を分けて記録」「動画と文書で異なるロジック」を全て実装しました。

**主な改善:**
1. ✅ PDF の履歴データが記録されるようになった
2. ✅ PDF と Video/Audio で異なる計算ロジック（秒/ページ vs 秒/分）
3. ✅ 文字起こし（抽出）と要約を分けて記録
4. ✅ 経験から学習し、推定精度が向上

**効果:**
- PDFを処理するたびに推定時間が正確になる
- ユーザーは信頼できる推定時間を見られる
- ボトルネック分析が可能
- モデル別の性能比較ができる
